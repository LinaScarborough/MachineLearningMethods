---
title: "ML1_Final_EDA_ShinyApp_included"
date: "2024-05-26"
output: 
  html_document:
    df_print: paged
    theme: "sandstone"
    css: "css/style.css"
runtime: shiny
---

# 1. Libraries

This section loads the necessary R packages for data manipulation,
visualization, and other tasks. If a package is not installed, it
installs it first and then loads it.

```{r setup, include=FALSE}
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
  install.packages("dplyr")
  library(dplyr)
}

# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
  install.packages("stringr")
  library(stringr)
}

# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
  install.packages("plotly")
  library(plotly)
}

# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
  install.packages("ggplot2")
  library(ggplot2)
}

# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
  install.packages("readxl")
  library(readxl)
}

# readr: For reading data
if (!require(readr, quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
  install.packages("treemapify")
}
library(treemapify)

# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
  install.packages("scales")
}
library(scales)

# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
  install.packages("patchwork")
}
library(patchwork)

# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
  install.packages("gridExtra")
}
library(gridExtra)

# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
  install.packages("RColorBrewer")
}
library(RColorBrewer)

 # forcats
if (!require(forcats, quietly = TRUE)) {
  install.packages("forcats")
}
library(forcats)

 # shiny
if (!require(shiny, quietly = TRUE)) {
  install.packages("shiny")
}
library(shiny)

 # GAM
if (!require(mgcv, quietly = TRUE)) {install.packages("mgcv")}
library(mgcv)

if (!require(effects, quietly = TRUE)) {install.packages("effects")}
library(effects)
```

# 2. Dataset

This section for loading the dataset from the provided URL and
displaying a summary of the data.

```{r loading, include=FALSE}
# Load dataset
df <- read.csv("kul100od1001.csv")
```

Here are some of the key attributes:

StichtagDatJahr: Year of the data record HalterId: Identifier for the
pet owner AlterV10Cd, AlterV10Lang, AlterV10Sort: Codes, descriptions,
and sorting for the age group of the pet owner SexCd, SexLang, SexSort:
Codes, descriptions, and sorting for the gender of the pet owner
KreisCd, KreisLang, KreisSort: Codes, descriptions, and sorting for the
district QuarCd, QuarLang, QuarSort: Codes, descriptions, and sorting
for the quarter Rasse1Text, Rasse2Text: Primary and secondary breed
texts of the pet RasseMischlingCd, RasseMischlingLang,
RasseMischlingSort: Codes, descriptions, and sorting for whether the pet
is a mixed breed RassentypCd, RassentypLang, RassentypSort: Codes,
descriptions, and sorting for the type of breed GebDatHundJahr: Year of
birth of the pet AlterVHundCd, AlterVHundLang, AlterVHundSort: Codes,
descriptions, and sorting for the age group of the pet SexHundCd,
SexHundLang, SexHundSort: Codes, descriptions, and sorting for the
gender of the pet HundefarbeText: Color of the pet AnzHunde: Number of
dogs

# 3. Translation

In this section, we duplicate and rename the dataframe df as df_EN for
the English version. Then, translations for column names in English are
defined. Following this, a function is employed to replace multiple
patterns at once for content translation. Patterns and replacements for
content translation, including translations for age groups, sexes, breed
types, and dog colors, are defined. After applying the translation
function across all columns, dog colors are also translated.

```{r translation, include=FALSE}

# Duplicate and rename df for English version
df_EN <- df

# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")

# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
  for (i in seq_along(patterns)) {
    text <- str_replace_all(text, patterns[i], replacements[i])
  }
  return(text)
}

# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")

# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))

# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")

# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)

# Optional: Print unique values to check the translations
print(unique(df_EN$MixedBreed))
print(unique(df_EN$BreedType))
print(unique(df_EN$DogColor))

head(df_EN)

write.csv(df_EN, "df_EN.csv", row.names = FALSE)
rm(df)
```

# 4. Unique Owner IDs

In the following R code snippet, we implement a method to distinguish
unique OwnerId values within our dataset. By marking the initial
occurrence of each OwnerId as unique, we facilitate further analyses
that may require the identification of distinct entries.

```{r df_unique_OwnerId, include=FALSE}
df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
dim(df_EN)

```

# 5. Refined Dataset

The R code below demonstrates the process of extracting a subset of
relevant columns from our comprehensive dataset df_EN, thereby creating
a streamlined DataFrame, new_df. This subset includes essential fields
such as KeyDateYear, OwnerId, and details regarding the dogs such as
PrimaryBreed and DogBirthYear. Additionally, the code converts the
NumberOfDogs column from its original format to a numeric type, ensuring
that subsequent data analysis can utilize numerical operations.

```{r new_df, include=FALSE}
# Create a new DataFrame with selected columns and convert 'NumberOfDogs' to numeric
new_df <- df_EN %>%
  select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear,    DogSex, NumberOfDogs, unique_OwnerId) %>%
  mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs)))

dim(new_df)
str(new_df)

```



# 6. ML Models


## 6.1. Predicting the Total Count of Dogs by District Over Years Using Linear Regression

In this section, the total count of dogs by district over the years is estimated using a linear regression model. The objective is to discern trends and foresee future changes in dog populations across different districts.

Using the aggregated data, a linear regression model is fitted with TotalDogs as the dependent variable and KeyDateYear and DistrictSort as the independent variables. This approach aids in understanding the relationship between dog counts, years, and districts. Predictions for future years up to 2030 are generated by creating new data points for each district and applying the model to estimate future dog counts.

```{r lm_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Ensure KeyDateYear is numeric
new_df$KeyDateYear <- as.numeric(as.character(new_df$KeyDateYear))

# Filter out districts other than 1 to 12 and set DistrictSort as a factor with levels 1 to 12
new_df <- new_df %>%
  filter(DistrictSort %in% 1:12) %>%
  mutate(DistrictSort = factor(DistrictSort, levels = 1:12))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the linear regression model
lm_model <- lm(TotalDogs ~ DistrictSort + KeyDateYear, data = annual_dog_counts)
summary(lm_model)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12), levels = 1:12)
)

# Predict dog counts
predictions <- predict(lm_model, newdata = new_data)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, data.frame(new_data, predicted_count = predictions), by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "LM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

The linear regression model demonstrates a significant and positive relationship between the total count of dogs and the year, suggesting an increasing trend in dog populations over time. Additionally, it shows significant differences in dog populations across different districts, with all district coefficients being highly significant.

**Visualization:**

The solid lines on the plot represent the model's predictions for the number of dogs in each district over time. The visualization reveals an overall increasing trend in dog populations across all districts from 2015 to 2030. Additionally, the model predicts varying growth rates and population levels across different districts, with some districts consistently showing higher or lower dog counts compared to others.

## 6.2. Generalized Linear Model (GLM) for Predicting Dog Populations by District

A Generalized Linear Model (GLM) is employed to predict the total count of dogs by district over the years. The goal is to capture trends and variations in dog populations using a model that can appropriately handle count data.

A GLM is fitted with TotalDogs as the dependent variable and KeyDateYear and DistrictSort as the independent variables. A Poisson distribution is chosen for the model since the dependent variable represents count data.Predictions are made for future years, up to 2030, by creating new data points for each district across these years and applying the GLM to estimate future dog counts.

```{r GLM_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Ensure KeyDateYear is numeric
new_df$KeyDateYear <- as.numeric(as.character(new_df$KeyDateYear))

# Filter out districts other than 1 to 12 and set DistrictSort as a factor with levels 1 to 12
new_df <- new_df %>%
  filter(DistrictSort %in% 1:12) %>%
  mutate(DistrictSort = factor(DistrictSort, levels = 1:12))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GLM model
glm_model <- glm(TotalDogs ~ KeyDateYear + DistrictSort, data = annual_dog_counts, family = poisson())

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12), levels = 1:12)
)

# Predict dog counts
predictions <- predict(glm_model, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GLM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

**Visualization:**

The plot displays both the observed data points and the predicted values from the GLM. The observed data points, shown as distinct points, represent the actual recorded number of dogs per district each year. The predicted trends, represented by solid lines, show the model's predictions for the number of dogs in each district over time. The plot reveals an overall increasing trend in dog populations across all districts from 2015 to 2030. The model predicts different growth rates and levels of dog populations across districts, with some districts consistently having higher or lower counts compared to others.

## 6.3. Generalized Additive Model (GAM) for Predicting Dog Populations by District

A Generalized Additive Model (GAM) is used to predict the total count of dogs by district over the years. The GAM approach allows for more flexibility in modeling the relationships between the predictors and the response variable, capturing non-linear trends and variations more effectively than linear models.

A GAM is fitted with TotalDogs as the dependent variable and KeyDateYear and DistrictSort as the independent variables. The model includes a smoothing spline for KeyDateYear to capture non-linear trends over time and a random effect for DistrictSort to account for variations across districts. A Poisson distribution with a log link function is used due to the count nature of the response variable. Predictions are made for future years, up to 2050, by creating new data points for each district and applying the GAM to estimate future dog counts.

```{r gam_model_simple - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with reduced knots
gam_model_simple <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 4) + s(DistrictSort, bs = "re"),
                        data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_simple)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12), levels = 1:12)
)

# Predict dog counts
predictions <- predict(gam_model_simple, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
new_df$DistrictSort <- factor(new_df$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

**Visualization:**

The plot shows both the observed and predicted values from the GAM. Observed data points, represented as distinct points, indicate the actual recorded number of dogs per district each year. Solid lines represent the model's predictions over time. The plot reveals an overall increasing trend in dog populations from 2015 to 2030, with varying growth rates and levels across different districts. This is evident in the differing slopes and intercepts of the lines. The GAM effectively captures these trends and variations, providing valuable insights for planning and resource allocation related to dog populations.

## 6.4. Refined Generalized Additive Model (GAM) for Predicting Dog Populations by District

A refined Generalized Additive Model (GAM) is used to predict the total count of dogs by district over the years. This model incorporates additional flexibility to capture the complex relationships and interactions between the predictors and the response variable more effectively.

The GAM is fitted with TotalDogs as the dependent variable, including smooth terms for KeyDateYear and DistrictSort, as well as an interaction term between KeyDateYear and DistrictSort. The refined GAM uses a more flexible smoothing spline for KeyDateYear with an increased number of knots (k = 8), allowing it to better capture non-linear trends over time. The refined model includes an interaction term between KeyDateYear and DistrictSort (s(KeyDateYear, by = DistrictSort, bs = "fs", m = 1)). This term allows the model to capture district-specific trends over time, accounting for how the effect of time on dog populations varies across different districts.
A Poisson distribution with a log link function is used due to the count nature of the response variable.

```{r gam_model_refined - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with the offset for TotalDogs
gam_model_refined <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 8) +
                 s(DistrictSort, bs = "re") +
                 s(KeyDateYear, by = DistrictSort, bs = "fs", m = 1),
                 data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_refined)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(gam_model_refined, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)
print(predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
new_df$DistrictSort <- factor(new_df$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

rm(prediction_data)


# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM refined: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

**Visualization:**

The plot displays both the observed data points and the predicted values from the refined GAM. The observed data points, shown as distinct points, represent the actual recorded number of dogs per district each year. The solid lines represent the model's predictions for the number of dogs in each district over time. The plot reveals an overall increasing trend in dog populations across all districts from 2015 to 2030, with varying growth rates and levels across different districts. This is evident in the differing slopes and intercepts of the lines.
The refined model's increased flexibility and inclusion of interaction terms allow it to better account for the complex, non-linear relationships in the data, resulting in more accurate and detailed predictions.

## 6.5. Model Comparison: Predicting Dog Populations by District

The previous models are compared to predict the total count of dogs by district over the years.The goal is to evaluate the performance and suitability of these models for capturing the trends and variations in dog populations.

A scatterplot of residuals versus fitted values is used to check the homogeneity of variance in residuals across the models. This helps in understanding the distribution of residuals and identifying any patterns or heteroscedasticity.

The effect of time on dog populations is examined for different districts using the refined GAM. This involves plotting the fitted values and confidence intervals over time for each district, providing insights into how the model captures temporal trends.

The models are compared using the Akaike Information Criterion (AIC), which helps in assessing the relative quality of the models. Lower AIC values indicate a better fit to the data.

```{r MODEL COMPARISON - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Scatterplot for checking homogeneity of variance in residuals, you can directly use a scatterplot
plot(gam_model_simple$fitted.values, resid(gam_model_simple), col = "blue", xlab = "Fitted values", ylab = "Residuals", main = "GAM Comparison: Residuals vs Fitted Values", pch = 8)
points(gam_model_refined$fitted.values, resid(gam_model_refined), col = "green", pch = 8)
points(glm_model$fitted.values, resid(glm_model), col = "orange", pch = 8)
legend("topright", legend = c("GLM", "GAM", "refined GAM"), col = c("orange", "blue", "green"), pch = 8)
grid()



# Extract and plot the effect of time for a few districts
library(effects)
for(district in unique(combined_data$prediction_count)[1:12]) {
  effect_data <- effect("KeyDateYear", gam_model_refined, xlevels = list(DistrictSort = district))
  effect_df <- as.data.frame(effect_data)

  ggplot(effect_df, aes(x = KeyDateYear, y = fit)) +
    geom_line(shade = TRUE, size = 1) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    labs(title = paste("Effect of Year in District", district),
         x = "Year", y = "Fitted TotalDogs Count") +
    theme_minimal()
}

# Check interactions for a specific district if needed

# Using AIC for model comparison
AIC(gam_model_simple, gam_model_refined)

# If possible, validate with a separate data set or cross-validation

```

**Conclusion:** 

By comparing the simple GAM, refined GAM, and GLM, it is possible to assess which model better captures the trends and variations in dog populations across districts. The refined GAM, with its increased flexibility and inclusion of interaction terms, is likely to provide a more accurate and detailed prediction. 










