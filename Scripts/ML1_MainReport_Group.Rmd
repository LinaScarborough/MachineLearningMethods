---
title: "EDA_ML1"
output: html_document
date: "2024-04-29"
---

# 1. Libraries
This section loads the necessary R packages for data manipulation, visualization, and other tasks. If a package is not installed, it installs it first and then loads it.

```{r setup, include=FALSE}
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
  install.packages("dplyr")
  library(dplyr)
}

# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
  install.packages("stringr")
  library(stringr)
}

# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
  install.packages("plotly")
  library(plotly)
}

# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
  install.packages("ggplot2")
  library(ggplot2)
}

# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
  install.packages("readxl")
  library(readxl)
}

# readr: For reading data
if (!require(readr, quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
  install.packages("treemapify")
}
library(treemapify)

# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
  install.packages("scales")
}
library(scales)

# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
  install.packages("patchwork")
}
library(patchwork)

# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
  install.packages("gridExtra")
}
library(gridExtra)

if (!require(gridExtra, quietly = TRUE)) {
  install.packages("rcolorbrewer")
}
library(RColorBrewer)
```

# 2. Dataset
This section for loading the dataset from the provided URL and displaying a summary of the data.

```{r loading, include=FALSE}
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")

```

# 3. Translation
In this section, we duplicate and rename the dataframe df as df_EN for the English version. Then, translations for column names in English are defined. Following this, a function is employed to replace multiple patterns at once for content translation. Patterns and replacements for content translation, including translations for age groups, sexes, breed types, and dog colors, are defined. After applying the translation function across all columns, dog colors are also translated.

```{r transation, include=FALSE}

### 3. ENGLISH TRANSLATION ###
# Duplicate and rename df for English version
df_EN <- df

# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")

# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
  for (i in seq_along(patterns)) {
    text <- str_replace_all(text, patterns[i], replacements[i])
  }
  return(text)
}

# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")

# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))

# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")

# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)

# Optional: Print unique values to check the translations
print(unique(df_EN$MixedBreed))
print(unique(df_EN$BreedType))
print(unique(df_EN$DogColor))

View(df_EN)
```

# 4. Validating Owner Identifiers
This output is a summary of the occurrences of each OwnerId within each KeyDateYear where there are more than one occurrence, indicating multiple entries or records for the same owner in that year.

KeyDateYear: This column represents the year in which the occurrences of the OwnerId were recorded.
OwnerId: This column shows the unique identifier of the owner.
Count: This column indicates the number of occurrences of each OwnerId within the corresponding KeyDateYear.

*RESULT*: The table summarizes 4,998 instances of owner identifiers (OwnerId) recorded across different years (KeyDateYear). Each row indicates the count of occurrences for a specific owner in a given year. For example, in 2015, there were 2 occurrences recorded for owner "100002", and similar counts for other owners listed in the table. This data offers insights into the distribution of occurrences among different owners over time.

```{r owner identifiers, include=TRUE}
# Count the occurrences of each OwnerId within each KeyDateYear
owner_repetitions_per_year <- df_EN %>%
  group_by(KeyDateYear, OwnerId) %>%
  summarize(Count = n(), .groups = 'drop') %>%
  filter(Count > 1)  # Keep only those with more than one occurrence in the same year

# Print the results
print(owner_repetitions_per_year)
```

# 5.Tracking Aging Dogs from 2015 to 2023

## 5.1. Including Unknown Data

To analyze the aging patterns of dogs from 2015 to 2023, we first preprocess the dataset to ensure the necessary variables are in the appropriate format. This includes converting DogAgeGroupCd to numeric and KeyDateYear to numeric. After this preprocessing step, we proceed with the following steps:

Identifying Dogs Present in 2015 and 2023: We filter the dataset to extract information about dogs present in 2015 and 2023, focusing on their OwnerId, PrimaryBreed, and SecondaryBreed.

Finding Dogs Present in Both Years: We find the intersection of dogs present in 2015 and 2023 to identify those that survived from 2015 to 2023.

Filtering Dataset for Surviving Dogs: Using the information obtained from the previous step, we filter the original dataset to retain records of dogs present in both 2015 and 2023.

Checking for Consistent Age Progression: We calculate the age difference for each dog between 2015 and 2023 and identify dogs with a consistent age progression of 8 years, assuming that DogAge reflects each dog's age accurately.

*RESULT*: This data suggests that many dogs observed in both 2015 and 2023 have aged consistently by 8 years, indicating a typical aging pattern over the observed period.

```{r tracking aging dogs with unknown, include=TRUE}
# This code chunk tracks the aging of dogs from 2015 to 2023, focusing on those with consistent age progression.

# Convert to numeric
df_EN <- df_EN %>%
  mutate(DogAge = as.numeric(as.character(DogAgeGroupCd)),  
  KeyDateYear = as.numeric(as.character(KeyDateYear)))

# Step 1: Identify dogs present in 2015
dogs_in_2015 <- df_EN %>%
  filter(KeyDateYear == 2015) %>%
  select(OwnerId, PrimaryBreed, SecondaryBreed)

# Step 2: Identify dogs present in 2023
dogs_in_2023 <- df_EN %>%
  filter(KeyDateYear == 2023) %>%
  select(OwnerId, PrimaryBreed, SecondaryBreed)

# Step 3: Intersect the two groups to find dogs present in both years
surviving_dogs <- intersect(dogs_in_2015, dogs_in_2023)

# Filter the original dataset for these dogs and years
surviving_dogs_records <- df_EN %>%
  semi_join(surviving_dogs, by = c("OwnerId", "PrimaryBreed", "SecondaryBreed")) %>%
  filter(KeyDateYear %in% c(2015, 2023))

# Check for consistent age progression for these dogs
surviving_dogs_age_check <- surviving_dogs_records %>%
  group_by(OwnerId, PrimaryBreed, SecondaryBreed) %>%
  summarise(AgeDifference = diff(sort(DogAge)))

# Dogs with consistent age progression
consistent_age_progression <- surviving_dogs_age_check %>%
  filter(AgeDifference == 8) 

print(consistent_age_progression)

```

## 5.2. Excluding Unknown Data

R code used to track the aging progression of dogs from 2015 to 2023 while excluding those with an 'Unknown' primary breed. This process involves identifying dogs present in both 2015 and 2023, filtering out those with an 'Unknown' primary breed, and then checking for consistent age progression among these dogs. The results are printed to examine dogs with an expected age difference of 8 years between 2015 and 2023.

*RESULT*:  ID 100002 has a Chihuahua with no secondary breed, and the age of this dog has increased by 8 years from 2015 to 2023. Similarly, each subsequent row provides information about different dogs owned by different individuals, their breeds, and the corresponding age differences over the specified period.

```{r tracking aging dogs without unknown, include=TRUE}

# Convert to numeric
df_EN <- df_EN %>%
  mutate(DogAge = as.numeric(as.character(DogAgeGroupCd)),  
  KeyDateYear = as.numeric(as.character(KeyDateYear)))

# Step 1: Identify dogs present in 2015 excluding "Unknown" PrimaryBreed
dogs_in_2015 <- df_EN %>%
  filter(KeyDateYear == 2015, PrimaryBreed != "Unknown") %>%
  select(OwnerId, PrimaryBreed, SecondaryBreed)

# Step 2: Identify dogs present in 2023 excluding "Unknown" PrimaryBreed
dogs_in_2023 <- df_EN %>%
  filter(KeyDateYear == 2023, PrimaryBreed != "Unknown") %>%
  select(OwnerId, PrimaryBreed, SecondaryBreed)

# Step 3: Intersect the two groups to find dogs present in both years
surviving_dogs <- intersect(dogs_in_2015, dogs_in_2023)

# Now, filter the original dataset for these dogs and years, excluding "Unknown" PrimaryBreed
surviving_dogs_records <- df_EN %>%
  filter(PrimaryBreed != "Unknown") %>%
  semi_join(surviving_dogs, by = c("OwnerId", "PrimaryBreed", "SecondaryBreed")) %>%
  filter(KeyDateYear %in% c(2015, 2023))

# Assuming DogAge is numeric. If not, ensure to convert it first.
# Check for consistent age progression for these dogs
surviving_dogs_age_check <- surviving_dogs_records %>%
  arrange(OwnerId, PrimaryBreed, SecondaryBreed, KeyDateYear) %>%
  group_by(OwnerId, PrimaryBreed, SecondaryBreed) %>%
  summarise(AgeDifference = diff(sort(DogAge)), .groups = 'drop')

# Dogs with consistent age progression, expected to be 8 years apart from 2015 to 2023
consistent_age_progression_2 <- surviving_dogs_age_check %>%
  filter(AgeDifference == 8)

# Display the results
print(consistent_age_progression_2)

```

# 6. Analyzing the Top Dog Breeds from 2015 to 2023

These codes calculates and visualizes the count of surviving dogs from 2015 to 2023 for the top 10 breeds based on their occurrence across all years.

## 6.1. Including Unknown Data

By first determining the breeds with the highest occurrence across all years, it ensures a comprehensive selection. Then, filtering the dataset for dogs with consistent age progression, it narrows down the focus to these top breeds. The resulting bar plot vividly illustrates the distribution of surviving dogs among these breeds, providing valuable insights into their prevalence over the specified timeframe.

```{r top dog breeds with unknown, include=TRUE}

# Calculate the top 10 breeds based on their occurrence across all years
top_10_breeds <- df_EN %>%
  count(PrimaryBreed, sort = TRUE) %>%
  slice_max(order_by = n, n = 10) %>% # Correctly select top 10
  pull(PrimaryBreed)

# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
  filter(PrimaryBreed %in% top_10_breeds)

# Pre-calculate the counts for plotting and ordering
top_breeds_counts <- top_breeds_surviving_dogs %>%
  count(PrimaryBreed) %>%
  arrange(desc(n))

# Visualize the count of surviving dogs from 2015 to 2023 in the top 10 breeds
ggplot(top_breeds_counts, aes(x = reorder(PrimaryBreed, n), y = n, fill = PrimaryBreed)) +
  geom_col() +
  theme_minimal() +
  labs(title = "Surviving Dogs from 2015 to 2023 by Top 10 Breeds",
       x = "Breed", y = "Count of Surviving Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_viridis_d() +
  theme(legend.position = "none")

```

## 6.2. Excluding Unknown Data

This code segment performs a refined analysis of aging dogs from 2015 to 2023, focusing specifically on the top 10 breeds while excluding any entries labeled as 'Unknown'. By filtering out these unknown entries from the dataset before calculating the breed occurrences, it ensures a more accurate representation of the prevailing breeds. 

```{r top dog breeds without unknown, include=TRUE}

# Exclude 'Unknown' from the dataset before calculating the top breeds
df_filtered <- df_EN %>%
  filter(PrimaryBreed != "Unknown")

# Calculate the top 10 breeds based on their occurrence across all years
top_11_breeds <- df_filtered %>%
  count(PrimaryBreed, sort = TRUE) %>%
  slice_max(order_by = n, n = 10) %>% # Correctly select top 10 excluding "Unknown"
  pull(PrimaryBreed)

# Filter the consistent_age_progression dataset for these top 10 breeds
top_breeds_surviving_dogs <- consistent_age_progression_2 %>%
  filter(PrimaryBreed %in% top_11_breeds)

# Pre-calculate the counts for plotting and ordering
top_breeds_counts <- top_breeds_surviving_dogs %>%
  count(PrimaryBreed) %>%
  arrange(desc(n))

# Visualize the count of surviving dogs from 2015 to 2023 in the top 10 breeds
ggplot(top_breeds_counts, aes(x = reorder(PrimaryBreed, n), y = n, fill = PrimaryBreed)) +
  geom_col() +
  theme_minimal() +
  labs(title = "Aging Dogs from 2015 to 2023 by Top 10 Breeds (Excluding 'Unknown')",
       x = "Breed", y = "Count of Surviving Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_viridis_d() +
  theme(legend.position = "none")

```

# 7. Yearly Dog Counts

After confirming successful conversion, we aggregated the data to compute the total number of dogs per year. The resulting counts were then visualized using histograms to illustrate the distribution over the years.

Furthermore, to understand the trend in dog population over time, we calculated the percentage change between consecutive years. This allowed us to identify any notable fluctuations or patterns in the data.

```{r yearly dog counts, include=TRUE}

df_EN <- df_EN %>% 
  mutate(NumberOfDogs = as.numeric(NumberOfDogs))

# Check for any conversion problems
sum(is.na(df_EN$NumberOfDogs))
df_EN$KeyDateYear <- as.numeric(as.character(df_EN$KeyDateYear))

# Aggregate data to get total number of dogs per year
yearly_dog_counts <- df_EN %>%
  group_by(KeyDateYear) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')

print(yearly_dog_counts)

# Create the histogram
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
  geom_col(fill = "skyblue", color = "black") +  # Using geom_col for clarity
  geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  
  theme_minimal() +
  labs(title = "Total Number of Dogs per Year",
       x = "Year",
       y = "Total Number of Dogs") +
  scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear, 
                     labels = yearly_dog_counts$KeyDateYear) +  
  scale_y_continuous(labels = scales::comma, 
                     breaks = seq(0, 10000, by = 1000),
                     limits = c(0, 10000)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


### Calculate the PERCENTAGE CHANGE for annotations ###
yearly_dog_counts <- yearly_dog_counts %>%
  arrange(KeyDateYear) %>%
  mutate(Change = c(NA, diff(TotalDogs)),
         PercentChange = Change / lag(TotalDogs) * 100)

# Create the base plot
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
  geom_col(fill = "skyblue", color = "black") +
  geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  # Dashed lines at specified counts
  geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +  # Add a linear trend line
  geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)), 
            vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
  theme_minimal() +
  labs(title = "Total Number of Dogs per Year",
       x = "Year",
       y = "Total Number of Dogs") +
  scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
  scale_y_continuous(labels = scales::comma, 
                     breaks = seq(0, 10000, by = 1000),  # Adjust y-axis to have units of 1000
                     limits = c(0, 10000)) +  # Ensure y-axis goes up to 10000
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom")

```


# 8. Total number of dogs per year by owner's Gender

## 8.1. Including owner repetitions

This code calculates the total number of dogs per year based on the owner's gender.

```{r yearly dog counts by owner's gender, include=TRUE}

# Convert KeyDateYear and NumberOfDogs to numeric 
df_EN$KeyDateYear <- as.numeric(as.character(df_EN$KeyDateYear))
df_EN$NumberOfDogs <- as.numeric(df_EN$NumberOfDogs)

# Aggregate data to get the total number of dogs per year for each gender
yearly_dog_counts_by_gender <- df_EN %>%
  group_by(KeyDateYear, OwnerSex) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
print(yearly_dog_counts_by_gender)

# Create histograms for male and female owners with dodging
ggplot(yearly_dog_counts_by_gender, aes(x = KeyDateYear, y = TotalDogs, fill = OwnerSex)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  theme_minimal() +
  labs(title = "Total Number of Dogs per Year by Owner's Gender",
       x = "Year",
       y = "Total Number of Dogs") +
  scale_fill_manual(values = c("male" = "blue", "female" = "pink")) +
  geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  # Dashed lines at specific counts
  scale_y_continuous(labels = scales::comma, 
                     breaks = seq(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE), by = 1000),  # Adjust y-axis to have units of 1000
                     limits = c(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE) + 1000)) +  # Set y-axis limits
  scale_x_continuous(breaks = yearly_dog_counts_by_gender$KeyDateYear, 
                     labels = yearly_dog_counts_by_gender$KeyDateYear) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## 8.2. Unique Owners 

We explore the unique owners per year based on gender. The analysis starts by counting each owner once per year, regardless of the number of dogs they own.

```{r yearly dog counts by unique owner's gender, include=TRUE}

# Step 1: Count each owner once per year regardless of the number of dogs
yearly_dog_counts_by_gender_unique <- df_EN %>%
  select(KeyDateYear, OwnerId, OwnerSex) %>%
  distinct(KeyDateYear, OwnerId, OwnerSex) %>%
  group_by(KeyDateYear, OwnerSex) %>%
  summarize(UniqueOwners = n(), .groups = 'drop')
print(yearly_dog_counts_by_gender_unique)

# Step 2: Create histograms for male and female owners without repetition
ggplot(yearly_dog_counts_by_gender_unique, aes(x = KeyDateYear, y = UniqueOwners, fill = OwnerSex)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  theme_minimal() +
  labs(title = "Unique Owners per Year by Gender",
       x = "Year",
       y = "Number of Unique Owners") +
  scale_fill_manual(values = c("male" = "blue", "female" = "pink")) +
  geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
  scale_y_continuous(labels = scales::comma) +
  scale_x_continuous(breaks = yearly_dog_counts_by_gender_unique$KeyDateYear) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

# 9. HEATMAP of total number of dogs per year by owner's Gender

We proceeded to create a heatmap illustrating the distribution of dogs based on the gender and age group of their owners across different years. First, we organized the data by grouping it according to the year, owner's age group, and gender. Then, we iterated through each year, generating separate heatmaps to visualize the data for that specific year.

## 9.1. Including owner repetitions

Each heatmap represents the total number of dogs in various age groups categorized by the gender of their owners. The color gradient within the heatmap indicates the intensity of dog ownership, with warmer colors representing higher dog counts. 

!!! I choose viridis here to as colour palette!!!

```{r heatmap by owner's gender, include=TRUE}

# Prepare the data
df_EN$OwnerSex <- factor(df_EN$OwnerSex, levels = c("female", "male"))

agg_data <- df_EN %>%
  group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')

# Loop through each year and create a separate plot
years <- unique(agg_data$KeyDateYear)

for (year in years) {
  yearly_data <- filter(agg_data, KeyDateYear == year)
  
  # Create the heatmap for the year
  p <- ggplot(yearly_data, aes(x = OwnerSex, y = OwnerAgeGroup, fill = TotalDogs)) +
    geom_tile() +
    scale_fill_viridis_c(option = "D", limits = c(0, 2000), name = "Total Dogs") +  # Fixed scale max at 2000
    theme_minimal() +
    labs(title = paste("Heatmap of Number of Dogs by Owner's Gender and Age Group in", year),
         x = "Owner's Gender",
         y = "Owner's Age Group",
         fill = "Total Number of Dogs") +
    theme(axis.text.y = element_text(angle = 45, hjust = 1))
  
  # Display the plot
  print(p)
}

```

## 9.2. Unique Owners 

To ensure uniqueness, we refined the aggregation process by counting each owner only once per age group and gender for each year.


!!! I choose spectral here to as colour palette!!!


```{r heatmap by unique owner's gender, include=TRUE}

# Adjust the aggregation to count each owner once per age group and gender, per year
owner_counts <- df_EN %>%
  select(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
  distinct() %>%
  group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
  summarize(UniqueOwners = n(), .groups = 'drop')

# Loop through each year and create a heatmap
years <- unique(owner_counts$KeyDateYear)

for (year in years) {
  yearly_data <- filter(owner_counts, KeyDateYear == year)
  
  p <- ggplot(yearly_data, aes(x = OwnerSex, y = OwnerAgeGroup, fill = UniqueOwners)) +
    geom_tile() +
    scale_fill_gradientn(colors = brewer.pal(11, "Spectral"), limits = c(0, 2000), name = "Total Dogs") +
    theme_minimal() +
    labs(title = paste("Heatmap of Unique Owners by Gender and Age Group in", year),
         x = "Owner's Gender",
         y = "Owner's Age Group",
         fill = "Number of Unique Owners") +
    theme(axis.text.y = element_text(angle = 45, hjust = 1))
  
  print(p)
}

```

# 10. TREEMAP of total number of dogs per year by owner's Gender

we explore the distribution of dogs owned across different age groups, categorized by gender. The treemaps provide an intuitive representation of the total number of dogs owned by female and male owners, highlighting variations in ownership patterns across age groups. Each square's size within the treemap corresponds to the total number of dogs owned in a specific age group. 

## 10.1. Including owner repetitions

```{r treemap by owner's gender, include=TRUE}

# Prepare datasets
female_owners_age_group <- df_EN %>%
  filter(OwnerSex == "female") %>%
  group_by(OwnerAgeGroup) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  mutate(OwnerSex = "Female") # Add gender indication

male_owners_age_group <- df_EN %>%
  filter(OwnerSex == "male") %>%
  group_by(OwnerAgeGroup) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  mutate(OwnerSex = "Male") # Add gender indication

# Combine the datasets
combined_data <- bind_rows(female_owners_age_group, male_owners_age_group)


ggplot(combined_data, aes(area = TotalDogs, fill = TotalDogs, 
                          label = paste(OwnerSex, OwnerAgeGroup, TotalDogs, sep = "\n"), 
                          subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", size=15, grow = TRUE) +
  scale_fill_gradient(low = "lightblue", high = "steelblue", name = "Total Dogs") +  # Gradient from light to dark blue
  labs(title = "Treemap of Number of Dogs Owned Across Age Groups by Gender",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

# Create treemaps for FEMALE AND MALE SEPARATELY
female_treemap <- ggplot(female_owners_age_group, aes(area = TotalDogs, fill = TotalDogs, 
                                                      label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"), 
                                                      subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
  scale_fill_gradient(low = "lightpink", high = "darkred", name = "Total Dogs") + 
  labs(title = "Treemap of Number of Dogs Owned by Female Owners",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

male_treemap <- ggplot(male_owners_age_group, aes(area = TotalDogs, fill = TotalDogs, 
                                                  label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"), 
               
                                                                                     subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
  scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Total Dogs") + 
  labs(title = "Treemap of Number of Dogs Owned by Male Owners",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

# Arrange the treemaps side by side using patchwork
female_treemap + male_treemap
```

## 10.2. Unique Owners 

!!!!!The grouping take time to process...too many ownerID!!!!!!!
#group_by(KeyDateYear, OwnerId, OwnerAgeGroup) %>%

```{r treemap by owner's gender, include=TRUE}

# Prepare datasets
female_owners_age_group_unique <- df_EN %>%
  filter(OwnerSex == "female") %>%
  group_by(KeyDateYear, OwnerId, OwnerAgeGroup) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  mutate(OwnerSex = "Female") # Add gender indication

male_owners_age_group_unique <- df_EN %>%
  filter(OwnerSex == "male") %>%
  group_by(KeyDateYear, OwnerId, OwnerAgeGroup) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  mutate(OwnerSex = "Male") # Add gender indication

# Combine the datasets
combined_data_unique <- bind_rows(female_owners_age_group_unique, male_owners_age_group_unique)


ggplot(combined_data_unique, aes(area = TotalDogs, fill = TotalDogs, 
                          label = paste(OwnerSex, OwnerAgeGroup, TotalDogs, sep = "\n"), 
                          subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", size=15, grow = TRUE) +
  scale_fill_gradient(low = "lightblue", high = "steelblue", name = "Total Dogs") +  # Gradient from light to dark blue
  labs(title = "Treemap of Number of Dogs Owned Across Age Groups by Gender",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

# Create treemaps for FEMALE AND MALE SEPARATELY
female_treemap_unique <- ggplot(female_owners_age_group_unique, aes(area = TotalDogs, fill = TotalDogs, 
                                                      label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"), 
                                                      subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
  scale_fill_gradient(low = "lightpink", high = "darkred", name = "Total Dogs") + 
  labs(title = "Treemap of Number of Dogs Owned by Female Owners",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

male_treemap_unique <- ggplot(male_owners_age_group_unique, aes(area = TotalDogs, fill = TotalDogs, 
                                                  label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"), 
               
                                                                                     subgroup = OwnerSex)) +
  geom_treemap() +
  geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
  scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Total Dogs") + 
  labs(title = "Treemap of Number of Dogs Owned by Male Owners",
       subtitle = "Size of area represents the total number of dogs",
       caption = "From 2015 to 2023") +
  theme(legend.position = "none")

# Arrange the treemaps side by side using patchwork
female_treemap_unique + male_treemap_unique

```



## 10.3. Including owner repetitions by year

```{r treemap by unique owner's gender, include=TRUE}
df_EN$NumberOfDogs <- as.numeric(df_EN$NumberOfDogs)

# Aggregate data by KeyDateYear, OwnerAgeGroup, and OwnerSex
agg_data_yearly <- df_EN %>%
  group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  mutate(YearGroup = as.factor(KeyDateYear)) # Adding YearGroup for plotting

# Get a list of unique years to iterate over
years <- unique(agg_data_yearly$KeyDateYear)

# Loop through each year and create separate treemaps for each gender, then combine them
for (year in years) {
  yearly_data_female <- filter(agg_data_yearly, KeyDateYear == year, OwnerSex == "female")
  yearly_data_male <- filter(agg_data_yearly, KeyDateYear == year, OwnerSex == "male")
  
  female_treemap <- ggplot(yearly_data_female, aes(area = TotalDogs, fill = TotalDogs, 
                                                   label = paste(OwnerAgeGroup, "\n", TotalDogs), 
                                                   subgroup = OwnerSex)) +
    geom_treemap() +
    geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
    scale_fill_gradient(low = "lightpink", high = "darkred") +
    labs(title = paste("Female - Year:", year),
         subtitle = "Size of area represents the total number of dogs") +
    theme(legend.position = "none")
  
  male_treemap <- ggplot(yearly_data_male, aes(area = TotalDogs, fill = TotalDogs, 
                                               label = paste(OwnerAgeGroup, "\n", TotalDogs), 
                                               subgroup = OwnerSex)) +
    geom_treemap() +
    geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
    scale_fill_gradient(low = "lightblue", high = "darkblue") +
    labs(title = paste("Male - Year:", year),
         subtitle = "Size of area represents the total number of dogs") +
    theme(legend.position = "none")
  
  # Arrange the treemaps side by side using patchwork
  combined_treemap <- female_treemap + male_treemap
  
  print(combined_treemap) # Display the combined plot
}
```

# 11. Total Count of Dogs by District

## 11.1. General

We focus on examining the annual distribution of dog populations across various districts. To achieve this, we have implemented a specific R script that systematically processes and visualizes data for each year from our dataset. 

```{r total count of dogs by district, include=TRUE}

#Adjusting DistrictSort to have levels from 1 to 12 as indicated
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Iterate over each year and create a bar plot for districts 1 through 12, excluding NAs
for (year in unique_years) {
  yearly_data <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    arrange(DistrictSort)  # Ensuring data is arranged by DistrictSort
  
  # Plot for the year with districts 1 through 12, including dashed lines at specified counts and standardized y-axis
  p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort)) +
    geom_col() +  # Using geom_col for bar plots
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_fill_viridis_d(name = "District") +
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District in", year),
         x = "District",
         y = "Total Number of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none")  # Removing legend for clarity
  
  print(p)  # Display the plot
}

```


## 11.2. By Dogs' gender

To enhance our understanding of the distribution of dogs across different districts and to introduce a gender perspective into our analysis, we have modified our approach to include a breakdown by gender. This adjustment allows us to observe not only the geographical distribution but also gender dynamics within the dog population each year.

```{r total count of dogs by district and by dog gender, include=TRUE}

# Ensure DistrictSort is a factor with levels from 1 to 12
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Iterate over each year and create a bar plot for districts 1 through 12, excluding NAs
for (year in unique_years) {
  yearly_data <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort, DogSex) %>%  # Group by district and dog sex
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    arrange(DistrictSort, DogSex)  # Arrange by DistrictSort and DogSex
  
  # Plot for the year with districts 1 through 12, differentiating by gender
  p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = DogSex)) +
    geom_col(position = position_dodge()) +  # Using geom_col with dodge to separate male and female bars
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +  # Adding dashed lines
    scale_fill_viridis_d(name = "Dog Gender") +
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +  # Standardized y-axis
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District and Gender in", year),
         x = "District",
         y = "Total Number of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "bottom")  # Adjust legend position for clarity
  
  print(p)  # Display the plot
}

```

## 11.3. By Owners' gender

In our ongoing effort to track and analyze the distribution of dogs across various districts annually, we calculate not only the total number of dogs per district but also distinguishes between male and female owners within the same visualization.

```{r total count of dogs by district and by gender, include=TRUE}

# Adjusting DistrictSort to have levels from 1 to 12 as indicated
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Iterate over each year and create a bar plot for districts 1 through 12, explicitly excluding NAs in DistrictSort
for (year in unique_years) {
  yearly_total <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
  
  yearly_gender <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort, OwnerSex) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    ungroup() %>%
    mutate(Position = as.numeric(DistrictSort) + ifelse(OwnerSex == "female", -0.2, 0.2))  # Adjust positions for clarity
  
  p <- ggplot() +
    geom_bar(data = yearly_total, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
    geom_point(data = yearly_gender, aes(x = Position, y = TotalDogs, color = OwnerSex), size = 3) +
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_fill_viridis_d() +
    scale_color_manual(values = c("female" = "pink", "male" = "blue")) +
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District in", year, "— Female vs Male"),
         subtitle = "Bar: Total Count | Points: Count by Gender",
         x = "District",
         y = "Total Count of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          )
  
  print(p)
}

```
## 11.4. By Unique Owners

```{r total count of dogs by district and by gender and unique owners, include=TRUE}

# Adjusting DistrictSort to have levels from 1 to 12 as indicated
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Iterate over each year and create a bar plot for districts 1 through 12, explicitly excluding NAs in DistrictSort
for (year in unique_years) {
  yearly_total <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
  
  yearly_gender <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort, OwnerSex) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    ungroup() %>%
    mutate(Position = as.numeric(DistrictSort) + ifelse(OwnerSex == "female", -0.2, 0.2))  # Adjust positions for clarity
  
  yearly_owner_count <- df_EN %>%
    filter(KeyDateYear == year) %>%
    distinct(OwnerId, OwnerSex) %>%
    group_by(OwnerSex) %>%
    summarize(UniqueOwners = n(), .groups = 'drop')
  
  p <- ggplot() +
    geom_bar(data = yearly_total, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
    geom_point(data = yearly_gender, aes(x = Position, y = TotalDogs, color = OwnerSex), size = 3) +
    geom_text(data = yearly_owner_count, aes(x = Inf, y = Inf, label = paste(UniqueOwners, "unique owner(s)"), hjust = 1, vjust = 1), size = 3, color = "black") + # Add text for unique owner count
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_fill_viridis_d() +
    scale_color_manual(values = c("female" = "pink", "male" = "blue")) +
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District in", year, "— Female vs Male"),
         subtitle = "Bar: Total Count | Points: Count by Gender",
         x = "District",
         y = "Total Count of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  
  print(p)
}

```

## 11.5. By BreedType

In order to deepen our analysis of dog populations across different districts annually, our R script now incorporates an additional layer of granularity by assessing dog counts not only by district but also by breed type. This enhancement aims to provide a more detailed view of the diversity within the canine populations across the various districts each year.

```{r total count of dogs by district and by breed type, include=TRUE}

# Adjusting DistrictSort to have levels from 1 to 12 as initially indicated
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

unique_years <- unique(df_EN$KeyDateYear)

for (year in unique_years) {
  yearly_total <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
  
  yearly_breed <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort), BreedType != "Unknown") %>%
    group_by(DistrictSort, BreedType) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    ungroup() %>%
    mutate(Position = as.numeric(DistrictSort))  # Position adjustment can be refined as needed
  
  p <- ggplot() +
    geom_bar(data = yearly_total, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
    geom_point(data = yearly_breed, aes(x = Position, y = TotalDogs, shape = BreedType), size = 3, position = position_jitterdodge(jitter.width = 0.2)) +
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_fill_viridis_d(name = "District") +
    scale_color_viridis_d() +  # Assuming BreedType can be color coded, adjust as needed
    scale_shape_manual(values = seq(1, 20)) +  # Manually specifying shapes for breed type distinction
    scale_size(range = c(1, 6), name = "Total Dogs per Breed Type") +  # Adjusting point size to reflect total dogs per breed type
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District in", year),
         subtitle = "Points indicate count by breed type",
         x = "District",
         y = "Total Count of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          )
  
  print(p)
}
```


## 11.6. By BreedType and Dogs'gender

In our continuing efforts to provide a comprehensive analysis of the dog populations within various districts, our latest R script has been enhanced to include not only total counts by district but also a detailed breakdown by breed type and gender.

```{r total count of dogs by district, breed type and dogs' gender, include=TRUE}
# Adjust DistrictSort to have levels from 1 to 12 as initially indicated
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

for (year in unique_years) {
  # Calculate total number of dogs per district for each year
  yearly_total <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort)) %>%
    group_by(DistrictSort) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
  
  # Calculate total number of dogs per district per breed type and gender
  yearly_breed_gender <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort), BreedType != "Unknown") %>%
    group_by(DistrictSort, BreedType, DogSex) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    ungroup() %>%
    mutate(Position = as.numeric(DistrictSort) + ifelse(DogSex == "female", -0.2, 0.2))  # Adjust position slightly for clarity
  
  # Plotting both total counts and counts by breed type and gender
  p <- ggplot() +
    geom_bar(data = yearly_total, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
    geom_point(data = yearly_breed_gender, aes(x = Position, y = TotalDogs, color = DogSex, shape = BreedType), size = 3, position = position_jitterdodge(jitter.width = 0.1)) +
    geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
    scale_fill_viridis_d(name = "District") +
    scale_color_manual(values = c("female" = "pink", "male" = "blue")) +
    scale_shape_manual(values = seq(1, 20)) +
    scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
    theme_minimal() +
    labs(title = paste("Total Count of Dogs by District, Breed, and Gender in", year),
         subtitle = "Bar: Total Count | Points: Count by Breed and Gender",
         x = "District",
         y = "Total Count of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

  print(p)
}
```


# 12. Distribution of Dog Age by Breed Type

## 12.1. General

We would like to highlight how age varies within and across breeds. This analysis is pivotal for understanding breed-specific longevity and health trends, which can inform breeders, veterinarians, and pet owners about typical lifespan expectations and potential age-related issues within breeds.

```{r dog age by breed type, include=TRUE}
# DOGAGE
# Convert 'DogBirthYear' and 'KeyDateYear' to numeric
df_EN <- df_EN %>%
  mutate(DogBirthYear = as.numeric(as.character(DogBirthYear)),
         KeyDateYear = as.numeric(as.character(KeyDateYear)),
         DogAge = KeyDateYear - DogBirthYear)

# Specify years where 'Unknown' BreedType should be ensured
specified_years <- c(2015, 2016, 2017, 2018, 2020)

# Loop through the specified years to ensure 'Unknown' BreedType is included
for(year in specified_years) {
  if(!"Unknown" %in% df_EN$BreedType[df_EN$KeyDateYear == year]) {
    # Create a placeholder row that matches the structure of df_EN but with 'Unknown' BreedType
    placeholder_row <- df_EN[1, ] # Copy the structure of the first row
    placeholder_row[1, ] <- NA # Set all values to NA
    placeholder_row$KeyDateYear <- year
    placeholder_row$BreedType <- "Unknown"
    placeholder_row$DogAge <- NA # DogAge for 'Unknown' will not be plotted but needs a placeholder
    
    # Append the placeholder row to df_EN
    df_EN <- rbind(df_EN, placeholder_row)
  }
}

# Update 'BreedType' to ensure 'Unknown' is always a level
df_EN$BreedType <- factor(df_EN$BreedType, levels = unique(c(as.character(df_EN$BreedType), "Unknown")))

# Plotting
unique_years <- unique(df_EN$KeyDateYear)

for (year in unique_years) {
  df_filtered <- df_EN %>%
    filter(KeyDateYear == year, DogAge >= 0 & DogAge <= 15 | is.na(DogAge)) %>%
    mutate(BreedType = factor(BreedType, levels = levels(df_EN$BreedType)))
  
  p <- ggplot(df_filtered, aes(x = BreedType, y = DogAge, fill = BreedType)) +
    geom_boxplot() +
    scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 1)) +
    theme_light() +
    labs(title = paste("Distribution of Dog Age by Breed Type in", year),
         x = "Breed Type", y = "Dog Age") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
}
```

## 12.2. By district

To advance our understanding of the age distribution among various dog breeds and to examine how these distributions vary across different districts annually with this R script.

```{r dog age by breed type and by district, include=TRUE}
# Ensure 'DistrictSort' is set as a factor with levels from 1 to 12 for proper ordering
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

unique_years <- unique(df_EN$KeyDateYear)

for (year in unique_years) {
  df_filtered <- df_EN %>%
    filter(!is.na(DistrictSort), KeyDateYear == year, (DogAge >= 0 & DogAge <= 15) | is.na(DogAge)) %>%
    mutate(BreedType = factor(BreedType, levels = levels(df_EN$BreedType))) %>%
    # Ensuring DistrictSort is used as intended
    mutate(DistrictSort = factor(DistrictSort, levels = as.character(1:12)))
  
  # Create the plot with DistrictSort used for faceting
  p <- ggplot(df_filtered, aes(x = BreedType, y = DogAge, fill = BreedType)) +
    geom_boxplot() +
    scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, by = 1)) +
    facet_wrap(~DistrictSort, scales = "free_x", nrow = 2) +  # DistrictSort controls the facet ordering
    theme_light() +
    labs(title = paste("Distribution of Dog Age by Breed Type in", year, "across Districts"),
         x = "Breed Type", y = "Dog Age") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  print(p)
}
```

# 13. Top 5 Primary Breeds

##13.1. Including Unknown

R script designed to analyze and visualize the distribution of the top five primary dog breeds in each district annually. 

```{r primary breeds, Unknown included, include=TRUE}
# Ensure 'DistrictSort' is set as a factor with levels from 1 to 12 for proper ordering
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
  n_breeds <- length(unique(data$PrimaryBreed))
  palette <- scales::hue_pal()(n_breeds)
  breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
  return(breed_color_map)
}

# Iterate over each year and create a bar plot for districts 1 through 12, excluding NAs
for (year in unique_years) {
  yearly_data <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort), (DogAge >= 0 & DogAge <= 15) | is.na(DogAge)) %>%
    group_by(DistrictSort, PrimaryBreed) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    arrange(DistrictSort, desc(TotalDogs)) %>%  # Arrange by DistrictSort and TotalDogs in descending order
    group_by(DistrictSort) %>%
    top_n(6, wt = TotalDogs) %>%  # Select top 5 PrimaryBreed for each DistrictSort based on TotalDogs
    ungroup()
  
  # Assign colors to PrimaryBreed
  breed_color_map <- assign_colors(yearly_data)
  
  # Plot for the year with districts 1 through 12
  p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
    geom_col(position = "stack") +  # Stacked bar plot
    scale_fill_manual(values = breed_color_map) +  # Set manual colors for PrimaryBreed
    geom_hline(yintercept = c(250, 500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_y_continuous(limits = c(0, 750), breaks = seq(0, 750, by = 250)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Top 5 Primary Breeds by Total Count of Dogs in", year),
         x = "District",
         y = "Total Number of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  
  print(p)  # Display the plot
}
```

## 13.2. Excluding Unknown

Explicitly excluding any entries categorized under "Unknown." This refined focus allows for a more precise and meaningful understanding of breed popularity and distribution, crucial for targeted animal welfare and urban planning strategies.

```{r primary breeds, Unknown excluded, include=TRUE}

# Ensure 'DistrictSort' is set as a factor with levels from 1 to 12 for proper ordering
df_EN$DistrictSort <- factor(df_EN$DistrictSort, levels = as.character(1:12))

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
  data <- data %>%
    filter(PrimaryBreed != "Unknown")
  n_breeds <- length(unique(data$PrimaryBreed))
  palette <- scales::hue_pal()(n_breeds)
  breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
  return(breed_color_map)
}

# Extract unique years for iteration
unique_years <- unique(df_EN$KeyDateYear)

# Iterate over each year and create a bar plot for districts 1 through 12, excluding NAs
for (year in unique_years) {
  yearly_data <- df_EN %>%
    filter(KeyDateYear == year, !is.na(DistrictSort), (DogAge >= 0 & DogAge <= 15) | is.na(DogAge)) %>%
    group_by(DistrictSort, PrimaryBreed) %>%
    summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
    filter(PrimaryBreed != "Unknown") %>%
    arrange(DistrictSort, desc(TotalDogs)) %>%  # Arrange by DistrictSort and TotalDogs in descending order
    group_by(DistrictSort) %>%
    top_n(5, wt = TotalDogs) %>%  # Select top 5 PrimaryBreed for each DistrictSort based on TotalDogs
    ungroup()
  
  # Assign colors to PrimaryBreed
  breed_color_map <- assign_colors(yearly_data)
  
  # Plot for the year with districts 1 through 12
  p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
    geom_col(position = "stack") +  # Stacked bar plot
    scale_fill_manual(values = breed_color_map) +  # Set manual colors for PrimaryBreed
    geom_hline(yintercept = c(250, 500), linetype = "dashed", color = "red") +  # Adding dashed lines at specified y-values
    scale_y_continuous(limits = c(0, 750), breaks = seq(0, 750, by = 250)) +  # Standardize y-axis up to 2000
    theme_minimal() +
    labs(title = paste("Top 5 Primary Breeds by Total Count of Dogs in", year),
         x = "District",
         y = "Total Number of Dogs") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  
  print(p)  # Display the plot
}

```




