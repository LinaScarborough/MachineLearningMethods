---
title: "ML1_Final_EDA_ShinyApp_included"
date: "2024-05-26"
output: 
  html_document:
    df_print: paged
    theme: "sandstone"
    css: "css/style.css"
runtime: shiny
---

# 1. Libraries

This section loads the necessary R packages for data manipulation,
visualization, and other tasks. If a package is not installed, it
installs it first and then loads it.

```{r setup, include=FALSE}
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
  install.packages("dplyr")
  library(dplyr)
}

# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
  install.packages("stringr")
  library(stringr)
}

# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
  install.packages("plotly")
  library(plotly)
}

# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
  install.packages("ggplot2")
  library(ggplot2)
}

# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
  install.packages("readxl")
  library(readxl)
}

# readr: For reading data
if (!require(readr, quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
  install.packages("treemapify")
}
library(treemapify)

# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
  install.packages("scales")
}
library(scales)

# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
  install.packages("patchwork")
}
library(patchwork)

# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
  install.packages("gridExtra")
}
library(gridExtra)

# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
  install.packages("RColorBrewer")
}
library(RColorBrewer)

 # forcats
if (!require(forcats, quietly = TRUE)) {
  install.packages("forcats")
}
library(forcats)

 # shiny
if (!require(shiny, quietly = TRUE)) {
  install.packages("shiny")
}
library(shiny)

 # GAM
if (!require(mgcv, quietly = TRUE)) {install.packages("mgcv")}
library(mgcv)

if (!require(effects, quietly = TRUE)) {install.packages("effects")}
library(effects)
```

# 2. Dataset

This section for loading the dataset from the provided URL and
displaying a summary of the data.

```{r loading, include=FALSE}
# Load dataset
df_EN <- read.csv("../Datasets/df_EN.csv")
```

# 4. Unique Owner IDs

In the following R code snippet, we implement a method to distinguish
unique OwnerId values within our dataset. By marking the initial
occurrence of each OwnerId as unique, we facilitate further analyses
that may require the identification of distinct entries.

```{r df_unique_OwnerId, include=FALSE}
df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
dim(df_EN)

```

# 5. Refined Dataset

The R code below demonstrates the process of extracting a subset of
relevant columns from our comprehensive dataset df_EN, thereby creating
a streamlined DataFrame, new_df. This subset includes essential fields
such as KeyDateYear, OwnerId, and details regarding the dogs such as
PrimaryBreed and DogBirthYear. Additionally, the code converts the
NumberOfDogs column from its original format to a numeric type, ensuring
that subsequent data analysis can utilize numerical operations.

```{r new_df, include=FALSE}
# Create a new DataFrame with selected columns and convert 'NumberOfDogs' to numeric
new_df <- df_EN %>%
  select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear,    DogSex, NumberOfDogs, unique_OwnerId) %>%
  mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs)))

dim(new_df)
str(new_df)

```



# 6. ML Models


## 6.1. LM: How do Dog Counts evolve over time?

```{r lm_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Ensure KeyDateYear is numeric
new_df$KeyDateYear <- as.numeric(as.character(new_df$KeyDateYear))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the linear regression model
lm_model <- lm(TotalDogs ~ DistrictSort + KeyDateYear, data = annual_dog_counts)
summary(lm_model)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(lm_model, newdata = new_data)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, data.frame(new_data, predicted_count = predictions), by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "LM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

## 6.2. GLM: How do Dog Counts evolve over time?

```{r GLM_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}
# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GLM model
glm_model <- glm(TotalDogs ~ KeyDateYear + DistrictSort, data = annual_dog_counts, family = poisson())

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(glm_model, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
new_df$DistrictSort <- factor(new_df$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GLM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```


## 6.3. GAM: How do Dog Counts evolve over time?

```{r gam_model_simple - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with reduced knots
gam_model_simple <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 4) + s(DistrictSort, bs = "re"),
                        data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_simple)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(gam_model_simple, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
new_df$DistrictSort <- factor(new_df$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

## 6.4. GAM refined: How do Dog Counts evolve over time?

```{r gam_model_refined - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- new_df %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with the offset for TotalDogs
gam_model_refined <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 8) +
                 s(DistrictSort, bs = "re") +
                 s(KeyDateYear, by = DistrictSort, bs = "fs", m = 1),
                 data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_refined)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(gam_model_refined, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)
print(predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
new_df$DistrictSort <- factor(new_df$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

rm(prediction_data)


# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM refined: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")
print(p)

```

## 6.5. GAM Comparison: How do Dog Counts evolve over time?

```{r MODEL COMPARISON - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, warning=FALSE}

# Scatterplot for checking homogeneity of variance in residuals, you can directly use a scatterplot
plot(gam_model_simple$fitted.values, resid(gam_model_simple), col = "blue", xlab = "Fitted values", ylab = "Residuals", main = "GAM Comparison: Residuals vs Fitted Values", pch = 8)
points(gam_model_refined$fitted.values, resid(gam_model_refined), col = "green", pch = 8)
points(glm_model$fitted.values, resid(glm_model), col = "orange", pch = 8)
legend("topright", legend = c("GLM", "GAM", "refined GAM"), col = c("orange", "blue", "green"), pch = 8)
grid()



# Extract and plot the effect of time for a few districts
library(effects)
for(district in unique(combined_data$prediction_count)[1:12]) {
  effect_data <- effect("KeyDateYear", gam_model_refined, xlevels = list(DistrictSort = district))
  effect_df <- as.data.frame(effect_data)

  ggplot(effect_df, aes(x = KeyDateYear, y = fit)) +
    geom_line(shade = TRUE, size = 1) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    labs(title = paste("Effect of Year in District", district),
         x = "Year", y = "Fitted TotalDogs Count") +
    theme_minimal()
}

# Check interactions for a specific district if needed

# Using AIC for model comparison
AIC(gam_model_simple, gam_model_refined)

# If possible, validate with a separate data set or cross-validation

```















