---
title: "Machine Learning Methods: a look into the dog register of the city of Zürich"
author: "Rina Gandolfi, Daniel Herrera & Lina Scarborough"
date: "2024-05-26"
output: 
  html_document:
    df_print: paged
    theme: "sandstone"
    css: "css/style.css"
    toc: true
    toc_float: true
runtime: shiny
---

```{r setup, include=FALSE}

# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
  install.packages("dplyr")
  library(dplyr)
}

# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
  install.packages("stringr")
  library(stringr)
}

# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
  install.packages("plotly")
  library(plotly)
}

# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
  install.packages("ggplot2")
  library(ggplot2)
}

# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
  install.packages("readxl")
  library(readxl)
}

# readr: For reading data
if (!require(readr, quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
  install.packages("treemapify")
}
library(treemapify)

# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
  install.packages("scales")
}
library(scales)

# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
  install.packages("patchwork")
}
library(patchwork)

# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
  install.packages("gridExtra")
}
library(gridExtra)

# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
  install.packages("RColorBrewer")
}
library(RColorBrewer)

 # forcats
if (!require(forcats, quietly = TRUE)) {
  install.packages("forcats")
}
library(forcats)

 # shiny
if (!require(shiny, quietly = TRUE)) {
  install.packages("shiny")
}
library(shiny)

 # treemap
if (!require(treemap, quietly = TRUE)) {
  install.packages("treemap")
} 
library(treemap)

```

## 1. Introduction

### 1.1. Presentation of the case

We introduce Pet Paradise, a successful Zürich-based pet shop business, wants to expand. However, the owner is not aware of current and future customer needs. The owner has approached us to advise what predictions we can make about canine breeds, ages, neighborhood concentrations and distributions, to figure out where to open the next Pet Paradise branch and what products to offer there.

The objective of our report is to advise Pet Paradise and predict dog breed trends, in order to facilitate targeted marketing. Our analysis delves into canine and pet owner data. We have explored Zürich's neighborhoods to identify prevailing canine demographics and trends. So our predictive analysis extends beyond just current demographics to anticipate future trends, allowing Pet Paradise to stay ahead of evolving customer needs. 

By monitoring shifts in dog ownership patterns, breed popularity, and lifestyle preferences (size, number of dogs), Pet Paradise can adapt its product offerings and marketing strategies.

With our help, Pet Paradise can leverage data-driven insights to grow their business and help Zurich’s canines live to their best health and dog-happiness. We envision Pet Paradise expanding into other cantons too if they foster the customer satisfaction to shape Switzerland’s pet industry landscape.

### 1.2. Motivations

Dogs are an integral part of urban communities, with pet ownership having grown parallel to population over the past decades. Zürich and its canton boast the largest population of dogs of any Swiss region, as suggested by a [2013 study](https://sat.gstsvs.ch/fileadmin/media/pdf/archive/2013/04/SAT155040219.pdf), proving the value of building a thorough data-driven interpretation of the markets associated with dog ownership. 

Additionally, in a [publication](https://statistik.stadt-zuerich.ch/modules/StatNat/1984/1984_ZSN_Hunde-und-Hundebesitzer-in-der-Stadt-Zuerich.pdf) by the Zürich City Police, historical records and concerns due to the environmental impact of an ever increasing canine population have led to stricter laws against dog-produced waste and specific taxing for dog owners. The implementation of dog registration procedures, which date back several hundred years, has facilitated the collection of valuable statistical data, which provides a glimpse into the relationship between owners and their pets across time (with owner personal information limitations, due to privacy concerns). The existence of such cohesive and easily available data has served as a strong motivating factor for our team to undertake the current project.

Moreover, our data science team consists of individuals who are deeply passionate about dogs, each with varying degrees of personal experience in pet ownership, and understand the importance of analyzing the current dynamics between humans and dogs in Switzerland from an analytical perspective.

### 1.3. Disclaimer

The analysis in this report is conducted purely for educational purposes, focusing solely on the statistical modeling and client recommendations. This means that within the confines of this project, sex values for an animal such as dogs and their human owners within the dataset are interpreted as binary. The findings presented here are not intended to reflect or endorse any particular social reflections related to Sex identity. We acknowledge that discussions surrounding Sex identity are multifaceted for individuals and communities.

---

## 2. Data exploration

### 2.1. Data source and preparation

As mentioned above, the main data has been sourced from the [opendata.swiss project](https://opendata.swiss/de/dataset/hundebestande-der-stadt-zurich-seit-2015/resource/5f8eafd2-367f-489c-a075-42426d14c586), having been collected and published by the Open Data Portal of the City Council of Zürich, under the name "Hundebestände der Stadt Zürich, seit 2015". The description of the data set from the original source is as follows:

_This dataset contains information on dogs and their owners from the municipal dog register since 2015. Information on the age group, Sex and statistical district of residence is provided for dog owners. The breed, breed type, sex, year of birth, age and color are recorded for each dog. The dog register is kept by the Dog Control Department of the Zurich City Police._

To ensure a seamless workflow and make variable interpretation easier for our group, we have undertaken several preparatory steps with the dataset. These include renaming columns and translating certain string values from German to English, along with performing some cleaning procedures.

The main source of data is the `kul100od1001.csv` file, which contains a collection of 70,967 dog registrations with 33 variables.

```{r loading, include=FALSE}

# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")

```

For the English version, translations for the column names are defined and a function is employed to replace multiple patterns at once for content translation. This includes translations for age groups, sexes, breed types, and dog colors. After applying the translation function across all relevant columns, dog colors are also translated. From this point forward, we will refer to variables and items exclusively by their translated English names.

```{r translation, include=FALSE}

# Check if "Datasets/df_EN.csv" exists
if (!file.exists("Datasets/df_EN.csv")) {
  # Duplicate and rename df for English version
  df_EN <- df
  
  # Define translations for column names in English
  colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
  
  # Define a function to replace multiple patterns at once
  replace_patterns <- function(text, patterns, replacements) {
    for (i in seq_along(patterns)) {
      text <- str_replace_all(text, patterns[i], replacements[i])
    }
    return(text)
  }
  
  # Define patterns and replacements for content translation
  patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
  replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
  
  # Apply the function across all columns
  df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
  
  # Color translation - can be further customized based on your dataset
  color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
  color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
  
  # Translate dog colors
  df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
  
  write.csv(df_EN, "Datasets/df_EN.csv", row.names = FALSE)
  
} else {
  print("English version already saved")
}

```

The next step involves identifying and marking the initial occurrence of each `OwnerId` as unique within the dataset. This distinction facilitates further analyses that may require the identification of distinct entries.

```{r df_unique_OwnerId, include=FALSE}

# Clean import of dataset
df_EN <- read.csv("Datasets/df_EN.csv")

df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
head(df_EN)

```

Finally, a subset of relevant columns is extracted from the comprehensive dataset, creating a streamlined dataframe named `df_EN_EDA`. The subset includes essential fields such as `KeyDateYear`, `OwnerId`, and details regarding the dogs, including `PrimaryBreed` and `DogBirthYear`. Additionally, the `NumberOfDogs` column is converted from its original format to a numeric type, ensuring that subsequent data analysis can utilize numerical operations.

```{r df_EN_EDA, include=FALSE}

df_EN_EDA <- df_EN %>%
  dplyr::select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear, DogAgeGroupCd, DogSex, NumberOfDogs, unique_OwnerId) %>%
  mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs))) %>% # Convert NumberOfDogs to numeric
  mutate(across(where(is.character), factor)) %>%
  mutate_at(vars(DistrictSort, QuarCd), factor)

```

We begin with a summary of the data, providing an overview of its structure and contents.


```{r structure, include=TRUE}

# Load dataset
str(df_EN)

```

As can be seen in the structure of the data, the set comprises several observations of diverse data types. Most variables are expressed three times as different types, as integers (coded and sorted form), as well as strings (text). Depending on their implementation in the study they have been selected in one of the three variants, therefore our selection of relevant observations can be summarized as follows:

**Numerical values**:

  - `KeyDateYear`: numerical value for the reference year
  - `OwnerId`: numerical identifier for the owner of the registered dog
  - `AgeV10Sort`: referring to the owner's age as a 10-year category
  - `DogBirthYear`: numerical value for the birth year of the dog
  - `DogAgeSort`: referring to the dog's age at the time of registration
  - `NumberOfDogs`: numerical counter of the dog count for each dog owner 
  
**Binary variables**: !!! Is breed multinomial or factor? !!!

  - `DogSexText`: numerical value indicating two states for the biological sex of the dog
  
**String values**:

  - `DistricText`: the name of each larger district of Zürich according to the official division
  - `QuarterText`: the name of the smaller neighbourhoods which comprise the larger districts
  - `Breed1Text` and `Breed1Text2`: referring to dog race denominations and information
  - `MixedBreedText`: additional information regarding race mixing in the dog
  - `DogColorText`: a descriptive name for the colour of the dog
  - `BreedTypeLong`: referring to the official dog type classification according to the [Zürich Cantonal Law](https://www.zh.ch/content/dam/zhweb/bilder-dokumente/themen/umwelt-tiere/tiere/veterinaeramt/hunde/publikationen/erlaeuterungenzuhuv.pdf)

---

### 2.2. Exploratory Data Analysis

#### 2.2.1. Analyzing Diversity in Dataset Features: Years, Owner IDs, and Age Groups

This series of R code snippets delves into the examination of key
features within the `df_EN_EDA` dataframe, focusing on the identification and
analysis of unique entries for `KeyDateYear`, `OwnerId`, and `OwnerAgeGroup`.
Each code section is designed to extract unique values, count these
entries, and where applicable, visualize the distribution. Such analysis
is integral for understanding the dataset's diversity across different
dimensions, helping to highlight temporal coverage, ownership
uniqueness, and demographic variations among owners.

```{r unique_years, include=TRUE}

# Extract and count unique years
unique_years <- unique(df_EN_EDA$KeyDateYear)
number_of_unique_years <- length(unique_years)
print(number_of_unique_years)
print(unique_years)

```

```{r unique_OwnerId, include=TRUE}

# Extract and count unique Owner IDs
unique_Owner <- unique(df_EN_EDA$OwnerId)
number_of_unique_Owner <- length(unique_Owner)
print(number_of_unique_Owner)

```

#### 2.2.2. Unique owners by year, by age group and by Sex

This section presents an interactive visualization that displays unique owner IDs by age group and Sex for a selected year. The user interface allows the selection of a year and a Sex, and the resulting plot shows the distribution of unique Owner IDs across different age groups based on the chosen criteria.

```{r shiny, unique owners by year, by age group and by Sex, echo=FALSE, message=FALSE, warning=FALSE}

# Define UI
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedSex", "Select Sex:",
                        choices = c("All" = "all", "Male" = "male", "Female" = "female")),
            helpText("Displays unique owner IDs by age group and selected Sex for the chosen year.")
        ),
        mainPanel(
            plotOutput("SexPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$SexPlot <- renderPlot({
        # Aggregate unique Owner IDs by Age Group, Year, and Sex
        if (input$selectedSex == "all") {
            # Sum across both Sexs
            unique_owner_counts_Sex <- df_EN_EDA %>%
                group_by(KeyDateYear, OwnerAgeGroup) %>%
                summarise(UniqueOwnerCountSex = n_distinct(OwnerId), .groups = 'drop')
        } else {
            # Filter for a specific Sex
            unique_owner_counts_Sex <- df_EN_EDA %>%
                group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
                summarise(UniqueOwnerCountSex = n_distinct(OwnerId), .groups = 'drop') %>%
                filter(OwnerSex == input$selectedSex)
        }

        # Adjust factor levels
        unique_owner_counts_Sex$OwnerAgeGroup <- factor(unique_owner_counts_Sex$OwnerAgeGroup,
                                                           levels = unique(df_EN_EDA$OwnerAgeGroup[order(df_EN_EDA$OwnerAgeGroup)]))

        # Filter data for the specific year
        data_for_year_Sex <- filter(unique_owner_counts_Sex, KeyDateYear == as.numeric(input$selectedYear))
        
        # Define gradient colors for discrete levels
        gradient_colors <- colorRampPalette(c("darkseagreen2", "deepskyblue1"))(length(levels(unique_owner_counts_Sex$OwnerAgeGroup)))
        names(gradient_colors) <- levels(unique_owner_counts_Sex$OwnerAgeGroup)

        # Create the plot
        ggplot(data_for_year_Sex, aes(x = OwnerAgeGroup, y = UniqueOwnerCountSex, fill = OwnerAgeGroup)) +
            geom_bar(stat = "identity", position = "dodge") +
            geom_text(aes(label = UniqueOwnerCountSex), vjust = -0.5, color = "black", size = 3.5) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            theme_minimal() +
            labs(title = paste("Unique Owner IDs by Age Group and", input$selectedSex, "in", input$selectedYear),
                 x = "Owner Age Group",
                 y = "Count of Unique Owner IDs",
                 fill = "Owner Age Group") +
            scale_fill_manual(values = gradient_colors) +
            scale_y_continuous(limits = c(0, max(2000, max(data_for_year_Sex$UniqueOwnerCountSex) + 500)), breaks = seq(0, 2000, by = 500)) +
            scale_x_discrete(labels = function(x) {
                x <- gsub("[0-9]+ to [0-9]+ years old", "", x)
                gsub("Unknown", "", x)
            })
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.3. Unique owners by age group over years

The following visualization shows the count of unique Owner IDs across different age groups over the years. The plot is generated by aggregating unique Owner IDs by age group and year, adjusting factor levels, and creating a line plot.

```{r cs seasonal trend of Age Group, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate unique Owner IDs by Age Group and Year
unique_owner_counts <- df_EN_EDA %>%
  group_by(KeyDateYear, OwnerAgeGroup) %>%
  summarise(UniqueOwnerCount = n_distinct(OwnerId), .groups = 'drop')

# Adjust factor levels in the aggregated data before plotting
unique_owner_counts <- unique_owner_counts %>%
  arrange(desc(UniqueOwnerCount)) %>%
  mutate(OwnerAgeGroup = fct_inorder(OwnerAgeGroup),
         KeyDateYear = as.numeric(as.character(KeyDateYear)))  # Convert KeyDateYear to numeric

# Define gradient colors for discrete levels
gradient_colors <- colorRampPalette(c("darkseagreen2", "deepskyblue2"))(length(levels(unique_owner_counts$OwnerAgeGroup)))
names(gradient_colors) <- levels(unique_owner_counts$OwnerAgeGroup)

# Create the line plot for all years with a line per age group
p <- ggplot(unique_owner_counts, aes(x = KeyDateYear, y = UniqueOwnerCount, group = OwnerAgeGroup, color = OwnerAgeGroup)) +
  geom_line(size = 1) +  # Add line
  geom_point(size = 3) +  # Add points
  geom_hline(yintercept = c(100, 500, 1000, 1500, 2000), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(x = "Year",
       y = "Count of Unique Owner IDs",
       color = "Owner Age Group") +  # Label for the legend
  scale_color_manual(values = gradient_colors) +  # Use gradient colors
  scale_y_continuous(limits = c(0, 2500), breaks = seq(0, 2500, by = 500)) +
  scale_x_continuous(breaks = seq(min(unique_owner_counts$KeyDateYear), max(unique_owner_counts$KeyDateYear), by = 1))  # Define breaks in the x-axis scale to show each year

# Print the plot
ggplotly(p)

```

#### 2.2.4. Yearly Dog Counts

After confirming successful conversion, we aggregated the data to compute the total number of dogs per year. The resulting counts were then visualized using histograms to illustrate the distribution over the years.

Furthermore, to understand the trend in dog population over time, we calculated the percentage change between consecutive years. This allowed us to identify any notable fluctuations or patterns in the data.

```{r shiny, yearly dog counts, echo=FALSE, message=FALSE, warning=FALSE}

df_EN_EDA2 <- df_EN_EDA

# Convert NumberOfDogs to numeric
df_EN_EDA2 <- df_EN_EDA2 %>% 
  mutate(NumberOfDogs = as.numeric(NumberOfDogs))

# Check for any conversion problems
sum(is.na(df_EN_EDA2$NumberOfDogs))

# Convert KeyDateYear to numeric
df_EN_EDA2$KeyDateYear <- as.numeric(as.character(df_EN_EDA2$KeyDateYear))

# Aggregate data to get total number of dogs per year
yearly_dog_counts <- df_EN_EDA2 %>%
  group_by(KeyDateYear) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')

# Calculate the percentage change for annotations
yearly_dog_counts <- yearly_dog_counts %>%
  arrange(KeyDateYear) %>%
  mutate(Change = c(NA, diff(TotalDogs)),
         PercentChange = Change / lag(TotalDogs) * 100)

# Define UI
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      helpText("Click on a year in the bar plot to see the percentage change in dog registrations."),
      plotOutput("dogPlot", click = "plot_click"),
      verbatimTextOutput("click_info")
    ),
    mainPanel(
      plotOutput("dogChangePlot")
    )
  )
)

# Define server logic
server <- function(input, output) {
  output$dogPlot <- renderPlot({
    ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
      geom_col(fill = "darkseagreen") +
      geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  
      theme_minimal() +
      labs(title = "Total Number of Dogs per Year",
           x = "Year",
           y = "Total Number of Dogs") +
      scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear, 
                         labels = yearly_dog_counts$KeyDateYear) +  
      scale_y_continuous(labels = scales::comma, 
                         breaks = seq(0, 10000, by = 1000),
                         limits = c(0, 10000)) + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  })
  
  output$click_info <- renderPrint({
    if (!is.null(input$plot_click)) {
      year_clicked <- round(input$plot_click$x)
      year_data <- yearly_dog_counts %>%
        filter(KeyDateYear == year_clicked)
      if (nrow(year_data) > 0) {
        cat("Year:", year_data$KeyDateYear, "\n")
        cat("Total Dogs:", year_data$TotalDogs, "\n")
        cat("Percentage Change:", sprintf("%.1f%%", year_data$PercentChange), "\n")
      } else {
        cat("No data available for the selected year.")
      }
    }
  })
  
  output$dogChangePlot <- renderPlot({
    ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
      geom_col(fill = "darkseagreen") +
      geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  
      geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +  
      geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)), 
                vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
      theme_minimal() +
      labs(title = "Total Number of Dogs per Year",
           x = "Year",
           y = "Total Number of Dogs") +
      scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
      scale_y_continuous(labels = scales::comma, 
                         breaks = seq(0, 10000, by = 1000),  
                         limits = c(0, 10000)) +  
      theme(axis.text.x = element_text(angle = 45, hjust = 1),
            legend.position = "bottom")
  })
}

shinyApp(ui = ui, server = server)

```


#### 2.2.5. Heatmap of total number of registered dogs per year 

A heatmap was created to illustrate the distribution of dogs based on the Sex and age group of their owners across different years. The data was organized by grouping it according to the year, owner's age group, and Sex. Separate heatmaps were generated for each year to visualize the data for that specific period.

Each heatmap represents the total number of dogs in various age groups, categorized by the Sex of their owners. The color gradient within the heatmap indicates the intensity of dog ownership, with warmer colors representing higher dog counts.

```{r shiny, heatmap, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            helpText("Displays a heatmap of unique owner counts by age group and Sex for the selected year.")
        ),
        mainPanel(
            plotOutput("ownerHeatmap")
        )
    )
)

server <- function(input, output) {
    output$ownerHeatmap <- renderPlot({
        # Filter data for the specific year selected by user
        df_subset <- df_EN_EDA[df_EN_EDA$KeyDateYear == as.numeric(input$selectedYear), ]

        # Prepare the data
        owner_counts <- df_subset %>%
          distinct(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
          group_by(OwnerAgeGroup, OwnerSex) %>%
          summarize(UniqueOwners = n(), .groups = 'drop')

        # Create the heatmap
        p <- ggplot(owner_counts, aes(x = OwnerSex, y = OwnerAgeGroup, fill = UniqueOwners)) +
            geom_tile() +
            scale_fill_gradientn(colors = brewer.pal(11, "Spectral"), 
                                  limits = c(0, max(owner_counts$UniqueOwners, na.rm = TRUE)), 
                                  name = "Total Owners") +
            theme_minimal() +
            labs(title = paste("Heatmap of Unique Owners by Sex and Age Group in", input$selectedYear),
                 x = "Owner's Sex",
                 y = "Owner's Age Group",
                 fill = "Number of Unique Owners") +
            theme(axis.text.y = element_text(angle = 45, hjust = 1))
        
        # Return the plot
        p
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.6. Total Count of Dogs

##### 2.2.6.1. Total Count of Dogs by District

The annual distribution of dog registrations across various districts is examined using an interactive Shiny application. Users can select a year to view the total count of dogs by district for that specific year. The data is processed and visualized to provide insights into the distribution patterns over time.

```{r shiny, total count of dogs by district, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            helpText("Displays the total count of dogs by district for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter and aggregate data based on the selected year, excluding District 15
        yearly_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(DistrictSort), DistrictSort != "15") %>%
            group_by(DistrictSort) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs))  # Arrange by TotalDogs in descending order

        # Create the bar plot
        p <- ggplot(yearly_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DistrictSort)) +
            geom_col() +
            geom_text(aes(label = TotalDogs), vjust = -0.3, color = "black", size = 3.5) +  # Add dog counts on bars
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d(name = "District") +
            scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1),
                  legend.position = "none")
        
        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

##### 2.2.6.2. Total Count of Dogs by District with Dogs'Sex

To enhance understanding of the distribution of dogs across different districts and introduce a Sex perspective into the analysis, the approach has been modified to include a breakdown by Sex. This adjustment allows observation of not only the geographical distribution but also Sex dynamics within the dog population each year.

```{r shiny, total count of dogs by district and dogs Sex, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedSex", "Select Sex:",
                        choices = c("All" = "all", "Male" = "male", "Female" = "female")),
            helpText("Displays the total count of dogs by district and Sex for the selected year, ordered by total count.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), 
                   !is.na(DistrictSort), 
                   DistrictSort != "15")  # Exclude District 15

        # Apply Sex filter if not "All"
        if (input$selectedSex != "all") {
            filtered_data <- filtered_data %>%
                filter(DogSex == input$selectedSex)
        }

        # Aggregate data by district and optionally by Sex
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, DogSex) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            ungroup() %>%
            arrange(desc(TotalDogs))  # Order by total dogs in descending order

        # Create the bar plot
        p <- ggplot(yearly_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DogSex)) +
            geom_col(position = position_dodge()) +
            geom_text(aes(label = TotalDogs), vjust = -0.3, color = "black", size = 3.5) +  # Add dog counts on bars
            geom_hline(yintercept = c(100, 500), linetype = "dashed", color = "red") +
            scale_fill_manual(values = c("male" = "darkseagreen", "female" = "salmon")) + 
            scale_y_continuous(limits = c(0, 800), breaks = seq(0, 800, by = 100)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District and Dog Sex in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1),
                  legend.position = "bottom")

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

##### 2.2.6.3. By district and Unique Owners' Sex

This Shiny application provides an interactive visualization of the total count of dogs by district and owner's Sex for a selected year. Users can select a year and the Sex of the owner to explore the distribution of dogs across different districts, facilitating insights into demographic and geographic trends in dog ownership.

```{r shiny, total count of dogs by unique owners Sex, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedSex", "Select Owner's Sex:", choices = c("Male" = "male", "Female" = "female")),
            helpText("Displays the total count of dogs by district and Sex for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(DistrictSort), DistrictSort != "")

        # If 'All' is not selected, further filter by Sex
        if (input$selectedSex != "All") {
            filtered_data <- filtered_data %>%
                filter(OwnerSex == input$selectedSex)
        }

        # Aggregate data by district and optionally by Sex
        aggregated_data <- filtered_data %>%
            group_by(DistrictSort) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs))

        # Create the plot using reordered DistrictSort based on TotalDogs
        p <- ggplot(aggregated_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DistrictSort)) +
            geom_col() +
            geom_text(aes(label = TotalDogs), vjust = -0.3) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d() +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District in", input$selectedYear,
                               if(input$selectedSex != "All") paste("—", input$selectedSex) else ""),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1),
                  legend.position = "none")  # Optionally remove the legend

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

##### 2.2.6.4. By district and Breed Type

To deepen the analysis of dog populations across different districts annually, the R script incorporates an additional layer of granularity by assessing dog counts not only by district but also by breed type. This enhancement provides a more detailed view of the diversity within the canine populations across various districts each year.

```{r shiny, total count of dogs by breedtype, echo=FALSE, message=FALSE, warning=FALSE}

# Define UI
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreedType", "Select Breed Type:", 
                        choices = c("All" = "All", unique(df_EN_EDA$BreedType))),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district and selected breed type for the selected year, excluding District 15.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
        
        # Convert DistrictSort to a factor with levels from 1 to 12
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Optionally include/exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(BreedType != "Unknown")
        }

        # Filter by selected breed type if not 'All'
        if (input$selectedBreedType != "All") {
            filtered_data <- filtered_data %>%
                filter(BreedType == input$selectedBreedType)
        }

        # Aggregate data by district and breed type
        breed_data <- filtered_data %>%
            group_by(DistrictSort, BreedType) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(10, wt = TotalDogs) %>%
            ungroup()

        # Generate the plot
        p <- ggplot(breed_data, aes(x = DistrictSort, y = TotalDogs, fill = BreedType)) +
            geom_col(position = "stack") +
            scale_fill_viridis_d() +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(1700, max(breed_data$TotalDogs, na.rm = TRUE))), breaks = seq(0, 1700, by = 100)) +
            theme_minimal() +
            labs(title = paste("Top 10 Breed Types by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

##### 2.2.6.5. By district, Breed Type and Dogs's Sex

In an effort to provide a more comprehensive analysis of dog populations within various districts, the latest R script has been enhanced to include not only total counts by district but also a detailed breakdown by breed type and Sex. This enhancement aims to offer a deeper understanding of the diversity and demographics of canine registrations across different regions.

```{r shiny, total count of dogs by breedtype and dogs Sex, echo=FALSE, message = FALSE, warning=FALSE}

# Define UI for the application
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreedType", "Select Breed Type:", choices = c("All", unique(df_EN_EDA$BreedType))),
            selectInput("selectedSex", "Select Sex:", choices = c("All", "Male" = "male", "Female" = "female")),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district, breed type, and Sex for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
        
        # Convert DistrictSort to a factor with levels from 1 to 12
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Optionally include/exclude unknown breeds
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(BreedType != "Unknown")
        }

        # Filter by selected breed type if not 'All'
        if (input$selectedBreedType != "All") {
            filtered_data <- filtered_data %>%
                filter(BreedType == input$selectedBreedType)
        }

        # Filter by selected Sex if not 'All'
        if (input$selectedSex != "All") {
            filtered_data <- filtered_data %>%
                filter(DogSex == input$selectedSex)
        }

        # Calculate total number of dogs per district
        breed_data <- filtered_data %>%
            group_by(DistrictSort, BreedType, DogSex) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            mutate(Position = as.numeric(DistrictSort) + ifelse(DogSex == "female", -0.2, 0.2))  # Position adjustment for clarity

        # Generate the plot
        p <- ggplot() +
            geom_bar(data = breed_data, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
            geom_point(data = breed_data, aes(x = Position, y = TotalDogs, color = DogSex, shape = BreedType), size = 3, position = position_jitterdodge(jitter.width = 0.1)) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d(name = "District", guide = "none") +
            scale_color_manual(values = c("female" = "salmon", "male" = "darkseagreen")) +
            scale_shape_manual(values = seq(1, 20)) +
            scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District, Breed, and Sex in", input$selectedYear),
                 subtitle = "Bar: Total Count | Points: Count by Breed and Sex",
                 x = "District",
                 y = "Total Count of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1))

        return(p)
    })
}

# Run the application
shinyApp(ui = ui, server = server)

```

---

#### 2.2.7. Top dog breeds

##### 2.2.7.1. Top dog breeds by year

This Shiny application provides a clear and dynamic way to visualize the most popular dog breeds each year, allowing for the inclusion or exclusion of unknown breeds. The color-coding of breeds enhances readability and helps in quickly identifying trends.

```{r shiny, top dog breeds by year, echo=FALSE, message=FALSE, warning=FALSE}

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
    n_breeds <- length(unique(data$PrimaryBreed))
    palette <- scales::hue_pal()(n_breeds)
    breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
    return(breed_color_map)
}


ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by year")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on the selected year
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear))

        # Optionally exclude unknown breeds
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Aggregate data by PrimaryBreed
        breed_data <- filtered_data %>%
            group_by(PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs)) %>%
            slice_max(order_by = TotalDogs, n = 10)

        # Check if breed data is empty
        if (nrow(breed_data) == 0) {
            return(ggplot() +
                   labs(title = "No data available for the selected year or criteria",
                        x = "", y = "") +
                   theme_minimal())
        }

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(breed_data)

        # Generate the plot
        p <- ggplot(breed_data, aes(x = reorder(PrimaryBreed, TotalDogs), y = TotalDogs, fill = PrimaryBreed)) +
            geom_col() +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(250, 500, 750, 1000), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(1250, max(breed_data$TotalDogs, na.rm = TRUE))), breaks = seq(0, max(750, max(breed_data$TotalDogs, na.rm = TRUE)), by = 250)) +
            theme_minimal() +
            labs(title = paste("Top 10 Primary Breeds", input$selectedYear),
                 x = "Primary Breed", y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

##### 2.2.7.2. Top dog breeds by district

This visualization enables users to explore the distribution of dog breeds across different districts for a selected year. It highlights the top 5 dog breeds in each district, allowing for a detailed understanding of breed trends and distribution patterns.

```{r shiny, primary breeds by district, echo=FALSE, message=FALSE, warning=FALSE}
  
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by district for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15")

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Ensure DistrictSort is a factor with levels correctly ordered
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Aggregate data
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(yearly_data)

        # Generate the plot
        p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
            geom_col(position = "stack") +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(150, 300, 450, 600), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(600, max(yearly_data$TotalDogs))), breaks = seq(0, max(600, max(yearly_data$TotalDogs)), by = 300)) +
            theme_minimal() +
            labs(title = paste("Top 5 Primary Breeds by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1))

        return(p)
    })
}

shinyApp(ui = ui, server = server)
```

```{r shiny, all primary breeds by district, echo=FALSE, message = FALSE, warning=FALSE}

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
    n_breeds <- length(unique(data$PrimaryBreed))
    palette <- scales::hue_pal()(n_breeds)
    breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
    return(breed_color_map)
}

# Define UI for the application
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreed", "Select Breed Type:", choices = NULL),  # Dynamically populated
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district and selected breed type for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

# Define server logic required to draw a plot
server <- function(input, output, session) {
    # Observe the selected year to update breed type options
    observe({
        year_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(PrimaryBreed), DistrictSort != "15") %>%
            group_by(PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs)) %>%
            slice_max(order_by = TotalDogs, n = 10)

        breed_choices <- c("All", year_data$PrimaryBreed)
        updateSelectInput(session, "selectedBreed", choices = breed_choices, selected = breed_choices[1])
    })

    output$breedPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # If 'All' is not selected for breed type, further filter by selected breed type
        if (input$selectedBreed != "All") {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed == input$selectedBreed)
        }
        
        # Ensure DistrictSort is a factor with levels correctly ordered
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Aggregate data by district and breed type
        aggregated_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(aggregated_data)

        # Generate the plot
        p <- ggplot(aggregated_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
            geom_col(position = "stack") +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(100, 250, 500), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(500, max(aggregated_data$TotalDogs))), breaks = seq(0, 500, by = 100)) +
            theme_minimal() +
            labs(title = paste("Top Breeds by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

# Run the application 
shinyApp(ui = ui, server = server)

```

```{r shiny, treemap, primary breeds by district, echo=FALSE, message = FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by district for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15")

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Aggregate data
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Plotting the treemap
        treemap(yearly_data,
                index = c("DistrictSort", "PrimaryBreed"),
                vSize = "TotalDogs",
                vColor = "TotalDogs",
                title = paste("Top 5 Primary Breeds by Total Count of Dogs in", input$selectedYear),
                palette = "Spectral")
    })
}

shinyApp(ui = ui, server = server)

```

---

## 3. Machine Learning Models

### 3.1. Linear Model: dog age by breed status

#### 3.1.1. Linear Model for hypothesis testing: dog age by breed status

For the first chapter in the machine learning models we begin with a linear model that will test the effect of a categorical variable. To do this we set ourselves the following question: _does the breed status have an effect on the age at which dogs are registered?_

Understanding typical registration ages for different breeds will allow Pet Paradise to target marketing effectively, reaching owners at the right stage of their pet ownership journey. Additionally, these insights can inform strategic inventory management, anticipating demand for breed-specific products and offering tailored advice to enhance customer satisfaction.

In the context of the question at hand, it is worth noting that linear models will not be employed to generate predictions from the provided data. Rather, they will be utilized to determine whether there is a linear correlation between the various states of categorical variables (such as pedigree dog, non-pedigree, etc.) and the response variable, which denotes the age of the dog.

```{r linearmodel_01, include=FALSE}

# Clean import of dataset
df_EN <- read.csv("Datasets/df_EN.csv")

# Removing outliers
df_EN_cleaned <- subset(df_EN, DogAgeGroupSort < 100)
# Setting MixedBreed to factor
df_EN_cleaned$MixedBreed <- factor(df_EN_cleaned$MixedBreed)
# Setting reference to pure breeds
df_EN_cleaned$MixedBreed <- relevel(df_EN_cleaned$MixedBreed, 
                                    ref = "Pedigree dog")

```

To answer this question we will consider the `DogAgeGroupSort` as the response variable, and the different levels of the categorical variable `MixedBreed` as predictors. We now direct our attention to the following set of boxplots showcasing the relevant variables.


```{r linearmodel_boxplots, echo=FALSE, fig.width=10, fig.height=8, fig.align='center'}

# Boxplots
boxplots_ggplot <- ggplot(df_EN_cleaned, aes(x = MixedBreed, y = DogAgeGroupSort, fill = MixedBreed)) +
  geom_boxplot() +
  labs(x = "Mixed Breed Status", y = "Dog Registration Age") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(boxplots_ggplot)

```

Based on the boxplots above, there does seem to be a difference in dog ages based on their breed status. Interestingly, the most extreme outliers are associated with pedigree dogs. We will continue by defining a linear model.

```{r linearmodel_lm01, echo=TRUE}

lm.dogs.1 <- lm(DogAgeGroupSort ~ MixedBreed, data = df_EN_cleaned)
summary(lm.dogs.1)

```

The intercept refers to the pure breed dogs, while the following predictors represent the differences between themselves and the intercept. The summary of the linear model suggests there is strong evidence that the mean age of pedigree dogs is not equal to 0 at the time of registration, with a value of 5.7 years, while the other three breed categories' ages differ significantly from that of pedigree dogs. The most noticeable difference is between pedigree dogs and those whose secondary breed is unknown, with the latter being 1.79 years older.

We follow up this insight by assessing the differences between each of them. 

```{r linearmodel_drop1, echo=TRUE}

drop1 <- drop1(lm.dogs.1, test = "F")
drop1

```

```rverbatim
# Single term deletions

Model:
DogAgeGroupSort ~ MixedBreed
           Df Sum of Sq     RSS    AIC F value    Pr(>F)    
<none>                  1216314 201636                      
MixedBreed  3     19384 1235698 202752  376.93 < 2.2e-16 ***
```

By performing single term deletions and evaluating the resulting statistics of the model, we find that the breed status does indeed have a significant effect on the age of dogs across its different levels, however limiting these observation to one level at a time.

We can further this insight by drawing a General Linear Hypothesis. We will consider all possible pairwise comparisons with a *Tukey Honest Significant Difference Test*.

```{r linearmodel_glth, include=FALSE, warning=FALSE, message=FALSE, error=FALSE, echo=FALSE}

if (!require(multcomp, quietly = TRUE)) {
  install.packages("multcomp")
  library(multcomp)
}

glth.test.1 <- glht(model = lm.dogs.1,
                    linfct = mcp(MixedBreed = "Tukey"))
summary(glth.test.1)

```

```{r linearmodel_glth_plot, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.align='center', include=TRUE, fig.width=10, fig.height=4, cache=TRUE}

par(mar = c(5, 30, 5, 5) + 0.1)  # c(bottom, left, top, right) + 0.1
plot(glth.test.1,
     main = "Tukey Honest Significant Difference Test",
     sub = "95% family-wise confidence level")

```

In the above _Tukey Honest Significant Difference Test_ the similarity between means of different pairs is shown based on how different they are, with closeness to 0 representing no difference in their means. This, along with the 95% confidence intervals, provides an illustrative insight into pairwise variations.

---

#### 3.1.2. Linear Model: dog count over time

As an additional implementation of linear models, we now aim at answering the following research question: _how do dog counts evolve over time?_ To do so we will build a linear model that will provide some information about the trends in the time series of registered dog count data over the time period recorded, as well as some predictions for the following 10 years.

```{r linearmodel2_count, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Declare the new copied dataframe
df_EN_lm <- df_EN_EDA

# Ensure KeyDateYear is numeric
df_EN_lm$KeyDateYear <- as.numeric(as.character(df_EN_lm$KeyDateYear))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_lm %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the linear regression model
lm_model <- lm(TotalDogs ~ DistrictSort + KeyDateYear, data = annual_dog_counts)
summary(lm_model)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(lm_model, newdata = new_data)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, data.frame(new_data, predicted_count = predictions), by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "LM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

---

### 3.2. Generalized Linear Model (Poisson)

We constructed a Poisson Generalized Linear Model (GLM) to estimate the number of dog registrations (`NumberOfDogs`) based on the predictors `KeyDateYear` and `DistrictCd`. The goal was to identify trends and distributions in dog ownership across Zurich’s neighborhoods to support Pet Paradise's expansion strategy.

```{r poisson_intro, include=TRUE}

first_poisson_model <- glm(NumberOfDogs ~ KeyDateYear + DistrictCd,
                     family = poisson,
                     data = df_EN)

summary(first_poisson_model)

```

```{r poisson_cross_validation, include=FALSE, cache=TRUE}

set.seed(123)
control <- trainControl(method = "cv", number = 5)

# Train the Poisson GLM model thanks to cross-validation
cv_model <- train(NumberOfDogs ~ KeyDateYear + DistrictCd,
                  data = df_EN, method = "glm", family = poisson, trControl = control)

```

```{r poisson_cross_Validation2, include=TRUE}

cv_model

```

We now interpret the results from the Generalized Linear Poisson Model:

- `KeyDateYear`: The coefficient for `KeyDateYear` is -0.0003 with a p-value of 0.832. There's no significant trend over the years in the number of dog registrations. Hence, seasonal trends in dog registrations are not a primary factor for Pet Paradise's planning.

- `DistrictCd`: The coefficient for the neighborhood is -0.0001 with a p-value of 0.927, so no significant difference in dog registrations across different districts. This suggests that district-specific variations in dog registrations might not be substantial.

Specifically in terms of client recommendations, geographical expansion can be addressed. The stable registration numbers mean that given that neither `KeyDateYear` nor `DistrictCd` significantly impact the number of dog registrations, dog ownership seems stable across different years and districts. Therefore, Pet Paradise can consider expanding uniformly across districts rather than focusing on specific areas with presumed higher dog populations.

Therefore in conclusion, this poisson GLM analysis shows a stability in numbers across Zurich. Pet Paradise should leverage this stability and expand based on other factors.

Model Deviance and AIC:

With a null deviance of 191.58 on 70,966 degrees of freedom, the high value indicates considerable variation in the number of dog registrations across the dataset. The residual deviance of 191.53 on 70,964 degrees of freedom how a minimal reduction from the null deviance which means that  the predictors in the model do not significantly improve the fit compared to the null model.

The high AIC value indicates that while the model may have a reasonable fit, it is quite complex relative to the amount of information it provides.
A Fisher Scoring Iterations of four iterations suggests that the model parameters have quickly converged, which we can expect for GLMs with well-behaved data.

Regarding the cross-validation, we used a 5-fold validation, i.e. breaking the data into five subsets, training on four, and testing on the fifth. The low Root Mean Square Error of 0.0593 shows that the model's predictions are close to the actual values of dog registrations.
This R-squared shows that the predictors (here `KeyDateYear` and `DistrictCd`) explain almost none of the variability in the number of dog registrations. This is consistent with the insignificant coefficients observed.

In terms of client insights, the null hypothesis was proven correct in this case; the stability in the number of dog registrations across different years and districts suggests that Pet Paradise can plan for uniform expansion without focusing on specific districts. Other factors such as owner's age, whether they own a pedigree dog or not, etc. might be more influential in determining the demand for pet services, which we will examine in further models.

```{r poisson_predictions, include=FALSE}

# Generate predictions using the fitted model
predictions <- predict(first_poisson_model, type = "response")

```

``` {r poisson_visualization, include=TRUE, fig.align='center', echo=TRUE, fig.keep='all', fig.width=8, fig.height=6}

# Visualize the actual vs predicted number of dogs
p <- ggplot(df_EN, aes(x = NumberOfDogs, y = predictions)) +
  geom_point() +
  labs(title = "Actual vs Predicted Number of Dogs",
       x = "Actual Number of Dogs",
       y = "Predicted Number of Dogs")

ggplotly(p)

```

The above visualization helps us see that there is a poor fit; if the model were performing well, it would be a more diagonal spread of points, showing a clear linear relationship between actual and predicted values. The current chart does not show this pattern, so it is suggesting that the model
is not capturing the variability in the actual data. Upon reflection, the model was refined to sum the number of dogs per year, i.e. aggregate it.

```{r poisson_2nd_model, include=FALSE}
# Reiteration of poisson model, now with dogs summed by year for prediction.

# I now sum/aggregate the data by year and district
sum_data <- df_EN %>%
  group_by(KeyDateYear, DistrictCd) %>%
  summarize(NumberOfDogs = sum(NumberOfDogs))

# New fit of  Poisson GLM model
second_poisson_model <- glm(NumberOfDogs ~ KeyDateYear + DistrictCd,
                     family = poisson, data = sum_data)

```

``` {r poisson_2nd_model_sum, include=TRUE, echo=TRUE}

summary(second_poisson_model)

```

```{r poisson_2nd_model_pred, include=FALSE}

predictions <- predict(second_poisson_model, type = "response")
sum_data$PredictedNumberOfDogs = predictions

```

``` {r poisson_2nd_model_vis, include=TRUE, fig.align='center', echo=TRUE, fig.keep='all', fig.width=8, fig.height=6}

p <- ggplot(sum_data, aes(x = NumberOfDogs, y = PredictedNumberOfDogs)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Actual vs Predicted Number of Dog Registrations",
       x = "Actual Number of Dog Registrations",
       y = "Predicted Number of Dog Registrations")

ggplotly(p)

```

To check which poisson model is better, we compare the goodness-of-fit. This can be done using AIC because the models come from the same dataset, have the same response variable, as well as the same poisson distribution. We also compare coefficients.


```{r poisson_comparisons_1, include=TRUE}

summary_first <- summary(first_poisson_model)
summary_first
summary_first$deviance[1]
summary_first$deviance[2]
summary_first$coefficients

```

```{r poisson_comparisons_2, include=TRUE}
summary_second <- summary(second_poisson_model)
summary_second
summary_second$deviance[1]
summary_second$deviance[2]
summary_second$coefficients

```

There is a big difference between the null deviance (24077) and residual (22173). The degrees of freedom here are lower, so the predictors improved the model's fit. The AIC value (23'067) is lower than the first model's AIC (142'281), meaning a better fit. The coefficients of the second model are statistically significant where p-value < 0.001, and shows an increase of registrations per year (RefYear = 0.044). The negative district coefficient needs to be log transformed to be interpreted since it's a Poisson model.

```rverbatim
exp(District coefficient) = exp(−0.009640) = ca. 0.96
```

The above value is a percentage, so for every one-unit increase in District (ie just one neighbourhood to the next), the predicted number of dog registrations approximately decreases by 0.96%.

---

#### 3.2.2. Generalized Linear Model: dog count over time

As a second implementation of Generalized Linear Models, we return to the previously introduced research question: _how do dog counts evolve over time?_

```{r GLM_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Declare the new copied dataframe
df_EN_glm <- df_EN_EDA
df_EN_glm$KeyDateYear <- as.numeric(df_EN_glm$KeyDateYear)


# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_glm %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GLM model
glm_model <- glm(TotalDogs ~ KeyDateYear + DistrictSort, data = annual_dog_counts, family = poisson())

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(glm_model, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
df_EN_glm$DistrictSort <- factor(df_EN_glm$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GLM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

---

### 3.3. Generalized Linear Model (Binomial)

We introduction our binomial GLM section by defining the following goal: _predicting a dog's sex based on its age_. In order to work with such models, the response variable must first be transformed to a 0-1 response, as it is originally coded as either 1 for male or 2 for female. Our objective is to assess if there is any significant relationship between dog age and the likelihood of it being either male or female.

```{r glm_bi_libraries, include=FALSE}

if (!require(reshape2, quietly = TRUE))
  {install.packages("reshape2")}
library(reshape2)

if (!require(MASS, quietly = TRUE))
  {install.packages("MASS")}
library(MASS)

if (!require(caret, quietly = TRUE))
  {install.packages("caret")}
library(caret)

if (!require(gplots, quietly = TRUE))
  {install.packages("gplots")}
library(gplots)

```

``` {r glm_bi_preparation, include=FALSE}

# binomials work on binary data only, so dog sex for this dataset must be 0 or 1. Ie Change from 1 and 2.
df_EN$DogSexCd[df_EN$DogSexCd == 1] <- 0
df_EN$DogSexCd[df_EN$DogSexCd == 2] <- 1

```

``` {r glm_bi_fit1, include=TRUE, echo=TRUE}

glm_dog_sex_age <- glm(DogSexCd ~ DogAgeGroupCd, family = binomial, data = df_EN)
summary(glm_dog_sex_age)

exp_coef <- exp(coef(glm_dog_sex_age))
percentage_change <- (exp_coef - 1) * 100
percentage_change

```

The coefficient for `DogAgeGroupCd` is 0.0035 with a p-value of 0.0104, indicating statistical significance.
For every year increase in dog age, the probability of being female increase by 0.35%, holding other variables constant.
While the statistical significance of the coefficient for a dog's age suggests that there is evidence to support the relationship between dog age and the probability of being female,
the practical significance of a 0.35% increase in odds may not be substantial enough to warrant immediate business decisions based solely on this finding.

Further analysis may be needed here. Although the hypothesis was to offer products tailored to the dog's age and Sex, and while age appears to influence sex likelihood, additional factors such as breed and size would provide a more sound business decision making.

So more investigation into factors would refine predictions. We look at dog breeds. 

``` {r glm_bi_prep, include=FALSE}

# Select my variables. Updated with Owner Age.
df <- df_EN[, c("PrimaryBreed", "DogAgeGroupCd", "DogSexCd", "OwnerAgeGroupCd")]

# clean NAs
missing_values <- colSums(is.na(df))
print(missing_values) # no missing values

summary(df$DogAgeGroupCd)
# output shows max value 999 -> nonsensical. It refers to meaning "age unknown". So we replace it with the average age.
mean_dog_age <- mean(df$DogAgeGroupCd[df$DogAgeGroupCd != 999], na.rm = TRUE)
df <- df %>%
  mutate(DogAgeGroupCd = ifelse(DogAgeGroupCd == 999, mean_dog_age, DogAgeGroupCd))
summary(df$DogAgeGroupCd) # now output makes much more sense.
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
#0.000   2.000   5.000   5.887   9.000  23.000

# Distributions
table(df$DogSexCd)
# The distribution of dog sexes shows there are 35,409 female dogs (coded 0) and 35,558 male dogs (coded 1).
# There's no significant skew towards one sex in the dataset.

# Favourite 5 breeds
breed_counts <- table(df$PrimaryBreed)
sorted_breeds <- sort(breed_counts, decreasing = TRUE)
top_5_breeds <- head(sorted_breeds, 5)
top_5_breeds

```


| Breed              | Unknown   | Chihuahua | Labrador Retriever  | Yorkshire Terrier | Jack Russel Terrier |
|--------------------|-----------|-----------|---------------------|-------------------|---------------------|
| Count              | 9095      | 4828      | 4198                | 2709              | 2579                |


The most popular dog is a unknown ie. mixed dog breed. So Pet Paradise must offer mixed breed foods and products. Not only purebred product offerings.

So instead, another sales approach. Let's say, Pet Paradise is trying to target specific dog or owner age groups for marketing or sales purposes. Pet Paradise wants to predict the likelihood of a pet owner in their 40s owning a top 5 breed (e.g., the Chihuahua) compared to owning an unknown breed. For this, a binomial logistic regression makes most sense to use. This is because the response variable is binary: either a pet owner owns a Chihuahua (let say, coded as 1) or they own an unknown breed (we will code this as 0).

In terms of identifying popular breeds based on age and sex, Pet Paradise wants to use a model's predictions to optimize inventory management by stocking up on products that are likely to be in higher demand based on the popularity of a given pedigree breed.

``` {r glm_bi_prep2, include=FALSE}

# Now that the top 5 breeds are identified, a new subset should be created for owners in their 40s and for the top 5 breeds
owner_40s_df <- df[df$OwnerAgeGroupCd == 40 & df$PrimaryBreed %in% names(top_5_breeds), ]

# Create a binary variable for Chihuahua ownership
owner_40s_df$ChihuahuaOwned <- ifelse(owner_40s_df$PrimaryBreed == "Chihuahua", 1, 0)

# Check if there are any 0s in the ChihuahuaOwned column
head(owner_40s_df)
any(owner_40s_df$ChihuahuaOwned == 0)  # Yes, we get TRUE because there are other breeds

# Check if there are any 0s in the ChihuahuaOwned column
any(owner_40s_df$ChihuahuaOwned == 0)  # Should be TRUE if there are other breeds

```


``` {r glm_bi_fit2, include=TRUE, echo=TRUE}

chihuahua_binomial <- glm(ChihuahuaOwned ~ 1, family = binomial, data = owner_40s_df)
summary(chihuahua_binomial)

```


``` {r glm_bi_fit2_odds, include=TRUE, echo=TRUE}

chihuahua_exp_coef <- exp(coef(chihuahua_binomial))
chihuahua_exp_coef
chihuahua_percentage_change <- (chihuahua_exp_coef - 1) * 100
chihuahua_percentage_change

```

We see that the log-odds of a 40-year-old owning a Chihuahua are -1.29, which is statistically significant. The exponentiated coefficient is 0.27, indicating that the odds of a 40-year-old owning a Chihuahua are 27%. If Pet Paradise targets typically well-earning professionals, i.e., adults in their 40s, and since the likelihood of a dog owner in their 40s owning a Chihuahua is relatively low, Pet Paradise diversify marketing efforts away from pedigree focus and rather highlight a broader range of mixed-breed foods, fur-shampoos and other products. This strategy will help attract well-earning customers who may own mixed or different breeds.

To check a last potential business case, we can check the reverse; predict which owner age group is more likely to own a Chihuahua, because we have a binary variable (ChihuahuaOwned: 1 for ownership and 0 for no ownership) and the remaining predictor variables (PrimaryBreed, DogAgeGroupCd, DogSexCd, and OwnerAgeGroupCd). We will try o predict which owner age group is more likely to own a Chihuahua.

```rverboatim
chihuahua_age_bracket <- glm(formula = ChihuahuaOwned ~ PrimaryBreed + DogAgeGroupCd + DogSexCd + OwnerAgeGroupCd, family = binomial, data = owner_40s_df)
summary(chihuahua_age_bracket)

# Collinearity because model didn't converge. We calculate variance inflation factors
vif_values <- car::vif(chihuahua_age_bracket)
vif_values
```

The VIF produced by the above code shows that the model has perfect multicollinearity. It creates in linear dependencies among predictor variables. What this means, is that when there are categorical variables with many levels, it leads to unreliable predictions. So, if Pet Paradise is trying to predict which customers want to buy a product based on their age braket, breed of dog, etc, such a model with these singularities might suggest targeting certain groups of customers when, in fact, the data is too ambiguous to make such recommendations confidently We will compare the first two of the three models to determine the better fit instead.

``` {r glm_bi_comp1, include=FALSE}

# AIC and BIC for Model 1: Dog Sex vs. Age
aic_model1 <- AIC(glm_dog_sex_age)
bic_model1 <- BIC(glm_dog_sex_age)

# AIC and BIC for Model 2: Chihuahua Ownership in 40s
aic_model2 <- AIC(chihuahua_binomial)
bic_model2 <- BIC(chihuahua_binomial)

```

``` {r glm_bi_comp2, include=TRUE, echo=TRUE}

cat("Model 1 - Dog Sex vs. Age:\n")
cat("AIC:", aic_model1, "\n")
cat("BIC:", bic_model1, "\n\n")

cat("Model 2 - Chihuahua Ownership in 40s:\n")
cat("AIC:", aic_model2, "\n")
cat("BIC:", bic_model2, "\n")

```

We see from the Akaike Information Criterion and Bayesian Information Criterion that the second model, i.e. Chihuahua Ownership in an owner's 40s, has much lower AIC and BIC values than the Dog Sex vs. Age model. So model 2 provides a better fit to the data. Because the models contain fewer than 2 terms, checking collinearity doesn't make sense. We check the confusion matrices instead.

``` {r glm_bi_comp3, include=TRUE, fig.align='center', echo=TRUE, fig.keep='all', fig.width=8, fig.height=6}

# Confusion matrix for Dog Sex vs. Age
predicted_probabilities <- predict(glm_dog_sex_age, type = "response")
predicted_classes <- ifelse(predicted_probabilities > 0.5, 1, 0)
confusion_glm1 <- table(df_EN$DogSexCd, predicted_classes)
confusion_glm1

```

``` {r glm_bi_comp4, include=FALSE}

# 1. Confusion matrix values
TN <- 15813
FP <- 19596
FN <- 14672
TP <- 20886

# accuracy and precision
accuracy <- ((TP + TN) / (TP + TN + FP + FN)) * 100
precision <- (TP / (TP + FP)) * 100

# sensitivity
recall <- (TP / (TP + FN)) * 100

```

The first confusion matrix shows that there are correctly predicted the negatives was 15,813 instances. The false positive representing incorrectly predicted the positive cases was 19,596 false positives. There were 14,672 false negative predictions and 20,886 true positives. This means the first binomial model has an accuracy of 52% and a precision of 52%. The Sensitivity was around 59%, where of all actual positive instances were correctly identified by the model.

The client question of this analysis was to develop and compare binomial logistic regression models to predict outcomes regarding dog ownership based on given variables. We examined on two main models: one predicting the sex of the dog based on its age group and another predicting the most popular pedigree ownership among dog owners in their prime income earning years in their 40s.

The first model offered insights into the relationship between dog age and sex but had limited predictive power. The second model provided a baseline probability of pedigree ownership based on created binary variables of ownership vs non-ownership to target a very specific demographic niche. While attempting to include multiple predictors in the third pedigree ownership model, perfect multicollinearity was detected, resulting in unstable estimates and difficulties in model convergence. For Pet Paradise, focusing on targeting broader product ranges to well-earning professionals, rather than narrowly focusing on pedigree breeds, could be more effective.

---

### 3.4. Generalized Additive Model

For the Generalized Additive Model chapter we again direct our attention to the previously introduced research question: _how do dog counts evolve over time?_

As a straightforward implementation of the GAM model, we set ourselves to produce a regression of the registered count data, grouped by districts of the city, analyze their evolution over time, and additionally provide predictions for the next 10 years.

```{r gam_libraries, include=FALSE}

if (!require(mgcv, quietly = TRUE)) {install.packages("mgcv")}
library(mgcv)

if (!require(effects, quietly = TRUE)) {install.packages("effects")}
library(effects)

```

#### 3.4.1. GAM model: dog count over time

```{r gam_model_simple - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

df_EN_gam <- df_EN_EDA

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_gam %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with reduced knots
gam_model_simple <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 4) + s(DistrictSort, bs = "re"),
                        data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_simple)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(gam_model_simple, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
df_EN_gam$DistrictSort <- factor(df_EN_gam$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

We now proceed to further omptimize the GAM model.

```{r gam_model_refined - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Create a subset of the data where DistrictSort is a factor
df_subset <- df_EN_gam %>%
  filter(!is.na(DistrictSort)) %>%
  mutate(DistrictSort = factor(DistrictSort, levels = as.character(1:12)))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_subset %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the simplified GAM model
gam_model_refined <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 8) +
                         s(DistrictSort, bs = "re"),
                         data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_refined)

# Predictions
new_data <- data.frame(
  KeyDateYear = rep(c(2015:2023, 2030, 2040, 2050), each = 12),
  DistrictSort = factor(rep(1:12, times = 12), levels = as.character(1:12))
)

# Predict dog counts
predictions <- predict(gam_model_refined, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM refined: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

#### 3.4.2. Model comparison

We now look at some comparison now between the above two models, as well as the GLM that was introduced earlier.

```{r gam_comparisons, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}

# Create data frames for each model's fitted values and residuals
df_gam_simple <- data.frame(
  fitted_values = gam_model_simple$fitted.values,
  residuals = resid(gam_model_simple),
  model = "Simple GAM"
)

df_gam_refined <- data.frame(
  fitted_values = gam_model_refined$fitted.values,
  residuals = resid(gam_model_refined),
  model = "Refined GAM"
)

df_glm <- data.frame(
  fitted_values = glm_model$fitted.values,
  residuals = resid(glm_model),
  model = "GLM"
)

# Combine the data frames
combined_data <- rbind(df_gam_simple, df_gam_refined, df_glm)

# Create the ggplot object
p <- ggplot(combined_data, aes(x = fitted_values, y = residuals, color = model)) +
  geom_point() +
  labs(
    title = "GAM Comparison: Residuals vs Fitted Values",
    x = "Fitted Values",
    y = "Residuals"
  ) +
  scale_color_manual(values = c("GLM" = "darksalmon", "Simple GAM" = "darkturquoise", "Refined GAM" = "goldenrod")) +
  theme_minimal() +
  theme(legend.position = "top")

# Convert the ggplot object to a Plotly object
ggplotly(p)

```

```{gam_comparisons_2, fig.align='center', echo=TRUE, message=FALSE, warning=FALSE}

# Extract and plot the effect of time for a few districts
library(effects)
for(district in unique(combined_data$prediction_count)[1:12]) {
  effect_data <- effect("KeyDateYear", gam_model_refined, xlevels = list(DistrictSort = district))
  effect_df <- as.data.frame(effect_data)

  ggplot(effect_df, aes(x = KeyDateYear, y = fit)) +
    geom_line(shade = TRUE, size = 1) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    labs(title = paste("Effect of Year in District", district),
         x = "Year", y = "Fitted TotalDogs Count") +
    theme_minimal()
}

```

```{gam_comparisons_AIC, echo=TRUE, include=TRUE}

aic_comparison <- AIC(gam_model_simple, gam_model_refined)
print(aic_comparison)

```

---

### 3.5. Artificial Neural Network

We start this chapter by posing the research question: _is a dog of pure or mixed breed, based on location and owner and dog’s characteristics?_

An artificial neural network (ANN) is the algorithm of choice for this assessment due to its capability to handle complex, non-linear relationships within the dataset. Dogs' breed may depend on various interacting factors, such as age, size, location, and owner demographics, which ANNs can effectively capture and analyze. 

Their scalability and adaptability make them robust for ongoing studies, while their multilayered learning allows the model to automatically identify the most significant features. We ultimately aim to accurately predict breed status and provide valuable insights for our suggested business project, as well as pet adoption agencies, veterinarians, or even urban planners of the city of Zurich.

Continuing with the development of models, and answering the above, we now look into the implementation of an Artificial Neural Network using the packages `nnet` and `caret` in R. The resulting classification result for the dependent variable will be produced by the model considering variables of both numerical and categorical type.

The target variable `MixedBreed` is of categorical type (factor in R), indicating the dog’s pedigree status, with 4 different possible responses, from pure breed to 3 different descriptors of breed mixing. For the sake of simplicity, the levels within the `MixedBreed` factor variable have been reduced to a binary response, indicating whether the dog is of pure pedigree or not. We consider that this response better fits the information needed for our business case. 

As explained above, the response variables of choice pertain to characteristics of the dog owners (their age, sex, and district), as well as some characteristics of the dogs (dog age and sex). The predictors are the following: `OwnerAgeGroupCd`, `OwnerSexCd`, `DistrictCd`, `DogAgeGroupCd` and `DogSexCd`. Although the model results suggest that incorporating additional predictors should be done to improve the model's accuracy, we have kept the current selection for learning purposes.

The libraries of choice are `nnet` and `caret`, the first one providing the functions for creating and training the model, and the latter providing an interface to further preprocess and train the model. This allowed to implement a 10-fold cross-validation during the training phase of the model building. It also allowed to establish a tune grid with various possible hyperparameters to test out different combinations and find the most optimal ones.

``` {r neuralnetwork_libraries, include=FALSE}

# Install dependencies

# For the ANNs
if (!require(nnet, quietly = TRUE)) {
  install.packages("nnet")
  library(nnet)
}
# For model training and evaluation
if (!require(caret, quietly = TRUE)) {
  install.packages("caret")
  library(caret)
}
# For the visualization
if (!require(gamlss.add, quietly = TRUE)) {
  install.packages("gamlss.add")
  library(gamlss.add)
}
# For the quality assessment
if (!require(ROCR, quietly = TRUE)) {
  install.packages("ROCR")
  library(ROCR)
}

```

```{r neuralnetwork_sampling, include=FALSE}

# Select a subset of variables of interest
variables_net <- c("OwnerAgeGroupCd",
                "OwnerSex", 
                "District",
                "DogAgeGroupCd",
                "DogSex", 
                "MixedBreed")
df_net <- df_EN[variables_net]

#### PREPARATION OF DATA: FACTORS AND SAMPLING ####

# Convert categorical variables to factors
df_net$OwnerAgeGroupCd <- as.integer(df_EN$OwnerAgeGroupCd)  # Keep as numerical
df_net$OwnerSex <- as.factor(df_EN$OwnerSex)
df_net$District <- as.factor(df_EN$District)
df_net$DogAgeGroupCd <- as.integer(df_EN$DogAgeGroupCd)      # Keep as numerical
df_net$DogSex <- as.factor(df_EN$DogSex)
df_net$MixedBreed <- as.factor(df_EN$MixedBreed)             # Response variable

# Creating a new binary target variable from multinomial
# Pedigree dog stays as such, all others are mixed breeds, and set to factor
df_net$BinaryMixedBreed <- ifelse(df_net$MixedBreed == "Pedigree dog",
                                 "Pedigree dog",
                                 "Mixed breed")
df_net$BinaryMixedBreed <- as.factor(df_net$BinaryMixedBreed)
df_net <- df_net[, -which(names(df_net) == "MixedBreed")] # Remove original var.

# Split the data into training and testing sets
# The split is done proportionally for the BinaryMixedBreed variable
set.seed(123)  # for reproducibility
trainIndex <- createDataPartition(df_net$BinaryMixedBreed,
                                  p = 0.8, 
                                  list = FALSE,
                                  times = 1)
df_train <- df_net[trainIndex, ]
df_test <- df_net[-trainIndex, ]

```

``` {r neuralnetwork_train, include=FALSE}

# Cache save location
model_path <- "ML1_Final_Dogs_cache/nnet/breed_net.rds"

if (file.exists(model_path)) {
  # Load the cached model
  breed_net <- readRDS(model_path)
} else {
  
  # Define the control function for training
  train_control <- trainControl(method = "cv", number = 10)
  
  # Hyperparameters
  grid <- expand.grid(size = c(5, 10, 15), decay = c(0.01, 0.001, 0.0001))
  
  set.seed(123)
  # Train neural network model with selected features, hyperparameter tuning
  breed_net <- train(BinaryMixedBreed ~ .,
                      data = df_train,
                      method = "nnet",
                      trControl = train_control,
                      tuneGrid = grid,
                      linout = FALSE,           # For categorical response
                      trace = TRUE,             # To see what's happening live
                      maxit = 10000)            # Max. number of iterations

  # Save the model to disk to ensure it is not re-trained
  saveRDS(breed_net, model_path)
  
}

```

```{r neuralnetwork_print, include=TRUE}

breed_net
breed_net$finalModel

```

```{r neuralnetwork_predict, include=FALSE}

# Make predictions on the test set
predictions_binary <- predict(breed_net, newdata = df_test)
predictions_binary <- factor(predictions_binary)  # Is this necessary?
df_test$BinaryMixedBreed <- factor(df_test$BinaryMixedBreed)

# Generate the confusion matrix
cm_binary <- confusionMatrix(predictions_binary, df_test$BinaryMixedBreed)
cm_binary

# Convert the confusion matrix to a data frame
cm_binary_df <- as.data.frame(cm_binary$table)

# Rename the columns for better readability
colnames(cm_binary_df) <- c("Prediction", "Reference", "Freq")

```

``` {r neuralnetwork_plot, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.align='center'}

#### PLOTTING THE MODEL ####

# Extract the final model
final_model <- breed_net$finalModel
# Plot the neural network
plot(final_model)

```

After running the code, the final model is a neural network with 16 input nodes, 15 hidden nodes, and 1 output node, totalling 271 weights. However, an evaluation of the confusion matrix and ROC curves indicates insufficient evidence to support the model's validity for the given variables. This issue might stem from the selection of variables; expanding the set to include more variables from the dataset might improve the model. Alternatively, it could be that an artificial neural network is not the most suitable model for addressing this particular research question.

```{r neuralnetwork_conf_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}

# Confusion matrix plot
net_ggplot <- ggplot(data = cm_binary_df, aes(x = Reference, y = Prediction, fill = Freq)) +
    geom_tile() +
    scale_fill_gradient(low = "mistyrose", high = "darksalmon") +
    geom_text(aes(label = Freq), vjust = 1) +
    theme_minimal() +
    labs(title = "Binary Confusion Matrix", x = "Reference", y = "Predicted") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(net_ggplot)

```

After building the model with an 80% training subset of the total dataset, we use it to predict values for the remaining 20%. We evaluate the model's performance using a confusion matrix, which allowe us to compare our predicted values with the actual values of the test subset. The model successfully classifies 10,098 dogs as pure-bred, with only 44 being misclassified. However, this good result is overshadowed by the misclassification of 4,020 mixed-breed dogs, with only 31 correct predictions. This suggests that the model wrongly tends to classify most dogs as pure-bred.

```{r neuralnetwork_quality, include=FALSE}

# Switch the type to "prob"
pred_prob <- predict(breed_net,
                    df_test,
                    decision.values=TRUE,
                    type = "prob")

# Extract probabilities of the positive class
pred_prob_positive <- pred_prob[, 2]

# Convert to a numeric vector
pred_numeric <- as.numeric(pred_prob_positive)

# Create the prediction object
pred <- ROCR::prediction(pred_numeric,
                         df_test$BinaryMixedBreed)


```



```{r neuralnetwork_ROC, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.align='center', include=TRUE, fig.width=8, fig.height=6, cache=TRUE}

perf <- ROCR::performance(pred, "tpr", "fpr")
plot(perf, lwd=2, col="darksalmon", main = "ROC Curve")
abline(a=0, b=1)

```

The *ROC Curve* displays a closeness to the diagonal, which raises the possibility that the model’s predictions are not accurate, and support the need to either review the model with more predictors or consider a different model to answer the question at hand altogether.

---

### 3.6. Support Vector Machine Model


``` {r svm_libraries, include=FALSE}

if (!require(e1071, quietly = TRUE)) {
  install.packages("e1071")
  library(e1071)
}

if (!require(MASS, quietly = TRUE)) {
  install.packages("MASS")
  library(MASS)
}

if (!require(caret, quietly = TRUE)) {
  install.packages("caret")
  library(caret)
}

if (!require(doParallel, quietly = TRUE)) {
  install.packages("doParallel")
  library(doParallel)
}

```

``` {r svm_prep, include=FALSE}

df_EN_svm <- df_EN

# Replacing dog age unknowns (999) with mean
mean_dog_age <- mean(df_EN_svm$DogAgeGroupCd[df_EN_svm$DogAgeGroupCd != 999], na.rm = TRUE)

df_EN_svm <- df_EN_svm %>%
  mutate(DogAgeGroupCd = ifelse(DogAgeGroupCd == 999, mean_dog_age, DogAgeGroupCd))

# Replacing owner age unknowns (999) with mean
mean_owner_age <- mean(df_EN_svm$OwnerAgeGroupCd[df_EN_svm$OwnerAgeGroupCd != 999], na.rm = TRUE)

df_EN_svm <- df_EN_svm %>%
  mutate(OwnerAgeGroupCd = ifelse(OwnerAgeGroupCd == 999, mean_owner_age, OwnerAgeGroupCd))

# For the following plots
count_data <- df_EN_svm %>% 
  group_by(DogAgeGroupCd, OwnerAgeGroupCd) %>% 
  summarize(count = n())

```

``` {r svm_plot1, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}

scatter_plot <- ggplot(count_data, aes(x = DogAgeGroupCd, y = OwnerAgeGroupCd, size = count)) +
  geom_point(color = "seagreen", alpha = 0.7) + 
  scale_size_continuous(range = c(4, 12)) + 
  labs(title = "Heatmap of Owner Age Group vs Dog Age Group",
       x = "Dog Age Group",
       y = "Owner Age Group") +
  theme_minimal()

ggplotly(scatter_plot)

```

``` {r svm_sampling_settings, include=FALSE}

set.seed(123)
intrain <- createDataPartition(y = df_EN_svm$OwnerAgeGroupCd, p = 0.7, list = FALSE)
training <- df_EN_svm[intrain, ]
testing <- df_EN_svm[-intrain, ]

trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3, verboseIter = TRUE)

```

``` {r svm_linear_tr, include=FALSE}

file_path <- "ML1_Final_Dogs_cache/svm/svm_linear_model.RDS"

if (!file.exists(file_path)) {
    # If the file doesn't exist, execute SVM model
    svm_linear <- train(OwnerAgeGroupCd ~ DogAgeGroupCd,
                        data = training,
                        method = "svmLinear",
                        trControl = trctrl,
                        trace = TRUE,
                        tuneLength = 10)

    saveRDS(svm_linear, file = file_path)
} else {
    # If the file exists, load the model
    svm_linear <- readRDS(file_path)
}

```

``` {r svm_linear_sum, fig.align='center', include=TRUE, fig.width=8, fig.height=6, cache=TRUE, echo=TRUE}

svm_linear

```


``` {r svm_linear_confusion, include=FALSE, cache=TRUE}

# Predictions on testing data
predictions <- predict(svm_linear, testing)
predictions <- round(predict(svm_linear, testing), -1) # Round to nearest x10

# Create a table of predicted vs. true values using the testing data
misclass <- table(predict = predictions, truth = round(testing$OwnerAgeGroupCd, -1))
misclass

# Convert misclass to a data frame
misclass_df <- as.data.frame.table(misclass)

```

The predicted results have been adjusted and rounded to their nearest multiple of 10, in order to be able to visualize them against the actual decade time ranges represented in the original data. The following confusion plot shows the frequency of guesses for each age range.

``` {r svm_linear_confusion_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}

svm_linear_conf <- ggplot(misclass_df, aes(x = truth, y = predict, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "seagreen") +
  theme_minimal() +
  labs(title = "Confusion Matrix - SVM Linear Kernel",
       x = "Reference",
       y = "Prediction",
       fill = "Frequency")

ggplotly(svm_linear_conf)

```

At a first glance, most of the predictions happen around the 30 age range, specifically misclassifications where the model predicts 40. This is an acceptable error, as it reflects the observations we have previously made that most dog owners belong to those two age groups. No predictions were made for ages outside of the 40-60 range in this case.

``` {r svm_radial_tr, include=FALSE}

file_path <- "ML1_Final_Dogs_cache/svm/svm_radial_model.RDS"

if (!file.exists(file_path)) {
    # If the file doesn't exist, execute SVM model
    svm_rbf <- train(OwnerAgeGroupCd ~ DogAgeGroupCd,
                     data = training,
                     method = "svmRadial",
                     trControl = trctrl,
                     trace = TRUE,
                     tuneLength = 10)

    saveRDS(svm_rbf, file = file_path)
} else {
    # If the file exists, load the model
    svm_rbf <- readRDS(file_path)
}

```

``` {r svm_radial_sum, fig.align='center', include=TRUE, fig.width=8, fig.height=6, cache=TRUE, echo=TRUE}

svm_rbf

```

``` {r svm_radial_confusion, include=FALSE}

if (!file.exists("ML1_Final_Dogs_cache/svm/svm_rbf_misclass.RDS")) {
  
  predictions <- predict(svm_rbf, testing)
  predictions <- round(predict(svm_rbf, testing), -1) # Round to nearest x10
  
  # Create a table of predicted vs. true values
  misclass <- table(predict = predictions, truth = round(testing$OwnerAgeGroupCd, -1))
  misclass_df <- as.data.frame.table(misclass)
  
  # Save the data frame to an .RDS file
  saveRDS(misclass_df, file = "ML1_Final_Dogs_cache/svm/svm_rbf_misclass.RDS")
  
} else {
  
  # Load the data frame from the .RDS file
  misclass_df <- readRDS("ML1_Final_Dogs_cache/svm/svm_rbf_misclass.RDS")
}

```

``` {r svm_radial_confusion_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}

svm_radial_conf <- ggplot(misclass_df, aes(x = truth, y = predict, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "turquoise4") +
  theme_minimal() +
  labs(title = "Confusion Matrix - SVM Radial Kernel",
       x = "Reference",
       y = "Prediction",
       fill = "Frequency")

ggplotly(svm_radial_conf)

```



---

## 4. Additional chapter

---

## 5. Conclusion

---

## 6. Appendix: Working with generative AI tools
