---
title: "Machine Learning Methods: a look into the dog register of the city of Zürich"
author: "Rina Gandolfi, Daniel Herrera & Lina Scarborough"
date: "2024-05-26"
output: 
  html_document:
    df_print: paged
    theme: "sandstone"
    css: "css/style.css"
runtime: shiny
---

```{r setup, include=FALSE}

# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
  install.packages("dplyr")
  library(dplyr)
}

# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
  install.packages("stringr")
  library(stringr)
}

# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
  install.packages("plotly")
  library(plotly)
}

# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
  install.packages("ggplot2")
  library(ggplot2)
}

# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
  install.packages("readxl")
  library(readxl)
}

# readr: For reading data
if (!require(readr, quietly = TRUE)) {
  install.packages("readr")
}
library(readr)

# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
  install.packages("treemapify")
}
library(treemapify)

# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
  install.packages("scales")
}
library(scales)

# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
  install.packages("patchwork")
}
library(patchwork)

# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
  install.packages("gridExtra")
}
library(gridExtra)

# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
  install.packages("RColorBrewer")
}
library(RColorBrewer)

 # forcats
if (!require(forcats, quietly = TRUE)) {
  install.packages("forcats")
}
library(forcats)

 # shiny
if (!require(shiny, quietly = TRUE)) {
  install.packages("shiny")
}
library(shiny)

 # treemap
if (!require(treemap, quietly = TRUE)) {
  install.packages("treemap")
} 
library(treemap)

```


## 1. Introduction

### 1.1. Presentation of the case

Pet Paradise, a successful Zürich-based pet shop business, wants to expand. However, the owner is not aware of current and future customer needs. The owner has approached us to advise what predictions we can make about canine breeds, ages, neighborhood concentrations and distributions, to figure out where to open the next Pet Paradise branch and what products to offer there.

The objective of our report is to advise Pet Paradise and predict dog breed trends, in order to facilitate targeted marketing. Our analysis delves into canine and pet owner data. We have explored Zürich's neighborhoods to identify prevailing canine demographics and trends. So our predictive analysis extends beyond just current demographics to anticipate future trends, allowing Pet Paradise to stay ahead of evolving customer needs. 

By monitoring shifts in dog ownership patterns, breed popularity, and lifestyle preferences (size, number of dogs), Pet Paradise can adapt its product offerings and marketing strategies.

With our help, Pet Paradise can leverage data-driven insights to grow their business and help Zurich’s canines live to their best health and dog-happiness. We envision Pet Paradise expanding into other cantons too if they foster the customer satisfaction to shape Switzerland’s pet industry landscape.

### 1.1. Motivations

Dogs are an integral part of urban communities, with pet ownership having grown parallel to population over the past decades. Zürich and its canton boast the largest population of dogs of any Swiss region, as suggested by a [2013 study](https://sat.gstsvs.ch/fileadmin/media/pdf/archive/2013/04/SAT155040219.pdf), proving the value of building a thorough data-driven interpretation of the markets associated with dog ownership. 

Additionally, in a [publication](https://statistik.stadt-zuerich.ch/modules/StatNat/1984/1984_ZSN_Hunde-und-Hundebesitzer-in-der-Stadt-Zuerich.pdf) by the Zürich City Police, historical records and concerns due to the environmental impact of an ever increasing canine population have led to stricter laws against dog-produced waste and specific taxing for dog owners. The implementation of dog registration procedures, which date back several hundred years, has facilitated the collection of valuable statistical data, which provides a glimpse into the relationship between owners and their pets across time (with owner personal information limitations, due to privacy concerns). The existence of such cohesive and easily available data has served as a strong motivating factor for our team to undertake the current project.

Moreover, our data science team consists of individuals who are deeply passionate about dogs, each with varying degrees of personal experience in pet ownership, and understand the importance of analyzing the current dynamics between humans and dogs in Switzerland from an analytical perspective.

---

## 2. Data exploration

### 2.1. Data source and preparation

As mentioned above, the main data has been sourced from the [opendata.swiss project](https://opendata.swiss/de/dataset/hundebestande-der-stadt-zurich-seit-2015/resource/5f8eafd2-367f-489c-a075-42426d14c586), having been collected and published by the Open Data Portal of the City Council of Zürich, under the name "Hundebestände der Stadt Zürich, seit 2015". The description of the data set from the original source is as follows:

_This dataset contains information on dogs and their owners from the municipal dog register since 2015. Information on the age group, gender and statistical district of residence is provided for dog owners. The breed, breed type, sex, year of birth, age and color are recorded for each dog. The dog register is kept by the Dog Control Department of the Zurich City Police._

To ensure a seamless workflow and make variable interpretation easier for our group, we have undertaken several preparatory steps with the dataset. These include renaming columns and translating certain string values from German to English, along with performing some cleaning procedures.

The main source of data is the `kul100od1001.csv` file, which contains a collection of 70,967 dog registrations with 33 variables.

```{r loading, include=FALSE}

# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")

```

For the English version, translations for the column names are defined and a function is employed to replace multiple patterns at once for content translation. This includes translations for age groups, sexes, breed types, and dog colors. After applying the translation function across all relevant columns, dog colors are also translated. From this point forward, we will refer to variables and items exclusively by their translated English names.

```{r translation, include=FALSE}

# Check if "Datasets/df_EN.csv" exists
if (!file.exists("Datasets/df_EN.csv")) {
  # Duplicate and rename df for English version
  df_EN <- df
  
  # Define translations for column names in English
  colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
  
  # Define a function to replace multiple patterns at once
  replace_patterns <- function(text, patterns, replacements) {
    for (i in seq_along(patterns)) {
      text <- str_replace_all(text, patterns[i], replacements[i])
    }
    return(text)
  }
  
  # Define patterns and replacements for content translation
  patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
  replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
  
  # Apply the function across all columns
  df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
  
  # Color translation - can be further customized based on your dataset
  color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
  color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
  
  # Translate dog colors
  df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
  
  write.csv(df_EN, "Datasets/df_EN.csv", row.names = FALSE)
  
} else {
  print("English version already saved")
}

```

The next step involves identifying and marking the initial occurrence of each `OwnerId` as unique within the dataset. This distinction facilitates further analyses that may require the identification of distinct entries.

```{r df_unique_OwnerId, include=FALSE}

# Clean import of dataset
df_EN <- read.csv("Datasets/df_EN.csv")

df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
head(df_EN)

```

Finally, a subset of relevant columns is extracted from the comprehensive dataset, creating a streamlined dataframe named `df_EN_EDA`. The subset includes essential fields such as `KeyDateYear`, `OwnerId`, and details regarding the dogs, including `PrimaryBreed` and `DogBirthYear`. Additionally, the `NumberOfDogs` column is converted from its original format to a numeric type, ensuring that subsequent data analysis can utilize numerical operations.

```{r df_EN_EDA, include=FALSE}

df_EN_EDA <- df_EN %>%
  select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear, DogAgeGroupCd, DogSex, NumberOfDogs, unique_OwnerId) %>%
  mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs))) %>% # Convert NumberOfDogs to numeric
  mutate(across(where(is.character), factor)) %>%
  mutate_at(vars(KeyDateYear, DistrictSort, QuarCd), factor)

str(df_EN_EDA)
head(df_EN_EDA, 5)

```

We begin with a summary of the data, providing an overview of its structure and contents.


```{r structure, include=TRUE}

# Load dataset
str(df_EN)

```

As can be seen in the structure of the data, the set comprises several observations of diverse data types. Most variables are expressed three times as different types, as integers (coded and sorted form), as well as strings (text). Depending on their implementation in the study they have been selected in one of the three variants, therefore our selection of relevant observations can be summarized as follows:

**Numerical values**:

  - `KeyDateYear`: numerical value for the reference year
  - `OwnerId`: numerical identifier for the owner of the registered dog
  - `AgeV10Sort`: referring to the owner's age as a 10-year category
  - `DogBirthYear`: numerical value for the birth year of the dog
  - `DogAgeSort`: referring to the dog's age at the time of registration
  - `NumberOfDogs`: numerical counter of the dog count for each dog owner 
  
**Binary variables**: !!! Is breed multinomial or factor? !!!

  - `DogSexText`: numerical value indicating two states for the biological sex of the dog
  
**String values**:

  - `DistricText`: the name of each larger district of Zürich according to the official division
  - `QuarterText`: the name of the smaller neighbourhoods which comprise the larger districts
  - `Breed1Text` and `Breed1Text2`: referring to dog race denominations and information
  - `MixedBreedText`: additional information regarding race mixing in the dog
  - `DogColorText`: a descriptive name for the colour of the dog
  - `BreedTypeLong`: referring to the official dog type classification according to the [Zürich Cantonal Law](https://www.zh.ch/content/dam/zhweb/bilder-dokumente/themen/umwelt-tiere/tiere/veterinaeramt/hunde/publikationen/erlaeuterungenzuhuv.pdf)

---

## 2.2. Exploratory Data Analysis

### 2.2.1. Analyzing Diversity in Dataset Features: Years, Owner IDs, and Age Groups

This series of R code snippets delves into the examination of key
features within the `df_EN_EDA` dataframe, focusing on the identification and
analysis of unique entries for `KeyDateYear`, `OwnerId`, and `OwnerAgeGroup`.
Each code section is designed to extract unique values, count these
entries, and where applicable, visualize the distribution. Such analysis
is integral for understanding the dataset's diversity across different
dimensions, helping to highlight temporal coverage, ownership
uniqueness, and demographic variations among owners.

```{r unique_years, include=TRUE}

# Extract and count unique years
unique_years <- unique(df_EN_EDA$KeyDateYear)
number_of_unique_years <- length(unique_years)
print(number_of_unique_years)
print(unique_years)

```

```{r unique_OwnerId, include=TRUE}

# Extract and count unique Owner IDs
unique_Owner <- unique(df_EN_EDA$OwnerId)
number_of_unique_Owner <- length(unique_Owner)
print(number_of_unique_Owner)

```

### 2.2.2. Unique owners by year, by age group and by gender

This section presents an interactive visualization that displays unique owner IDs by age group and gender for a selected year. The user interface allows the selection of a year and a gender, and the resulting plot shows the distribution of unique Owner IDs across different age groups based on the chosen criteria.

```{r shiny, unique owners by year, by age group and by gender, echo=FALSE, message=FALSE, warning=FALSE}

# Define UI
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedGender", "Select Gender:",
                        choices = c("All" = "all", "Male" = "male", "Female" = "female")),
            helpText("Displays unique owner IDs by age group and selected gender for the chosen year.")
        ),
        mainPanel(
            plotOutput("genderPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$genderPlot <- renderPlot({
        # Aggregate unique Owner IDs by Age Group, Year, and Gender
        if (input$selectedGender == "all") {
            # Sum across both genders
            unique_owner_counts_gender <- df_EN_EDA %>%
                group_by(KeyDateYear, OwnerAgeGroup) %>%
                summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop')
        } else {
            # Filter for a specific gender
            unique_owner_counts_gender <- df_EN_EDA %>%
                group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
                summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop') %>%
                filter(OwnerSex == input$selectedGender)
        }

        # Adjust factor levels
        unique_owner_counts_gender$OwnerAgeGroup <- factor(unique_owner_counts_gender$OwnerAgeGroup,
                                                           levels = unique(df_EN_EDA$OwnerAgeGroup[order(df_EN_EDA$OwnerAgeGroup)]))

        # Filter data for the specific year
        data_for_year_gender <- filter(unique_owner_counts_gender, KeyDateYear == as.numeric(input$selectedYear))
        
        # Create the plot
        ggplot(data_for_year_gender, aes(x = OwnerAgeGroup, y = UniqueOwnerCountGender, fill = OwnerAgeGroup)) +
            geom_bar(stat = "identity", position = "dodge") +
            geom_text(aes(label = UniqueOwnerCountGender), vjust = -0.5, color = "black", size = 3.5) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            theme_minimal() +
            labs(title = paste("Unique Owner IDs by Age Group and", input$selectedGender, "in", input$selectedYear),
                 x = "Owner Age Group",
                 y = "Count of Unique Owner IDs") +
            scale_fill_brewer(palette = "Paired") +
            scale_y_continuous(limits = c(0, max(2000, max(data_for_year_gender$UniqueOwnerCountGender) + 500)), breaks = seq(0, 2000, by = 500)) +
            scale_x_discrete(labels = function(x) {
                x <- gsub("[0-9]+ to [0-9]+ years old", "", x)
                gsub("Unknown", "", x)
            })
    })
}

shinyApp(ui = ui, server = server)

```

### 2.2.3. Unique owners by age group over years

The following visualization shows the count of unique Owner IDs across different age groups over the years. The plot is generated by aggregating unique Owner IDs by age group and year, adjusting factor levels, and creating a line plot.

```{r cs seasonal trend of Age Group, echo=FALSE, message=FALSE, warning=FALSE}

# Aggregate unique Owner IDs by Age Group and Year
unique_owner_counts <- df_EN_EDA %>%
  group_by(KeyDateYear, OwnerAgeGroup) %>%
  summarise(UniqueOwnerCount = n_distinct(OwnerId), .groups = 'drop')

# Adjust factor levels in the aggregated data before plotting
unique_owner_counts <- unique_owner_counts %>%
  arrange(desc(UniqueOwnerCount)) %>%
  mutate(OwnerAgeGroup = fct_inorder(OwnerAgeGroup),
         KeyDateYear = as.numeric(as.character(KeyDateYear)))  # Convert KeyDateYear to numeric

# Create the line plot for all years with a line per age group
p <- ggplot(unique_owner_counts, aes(x = KeyDateYear, y = UniqueOwnerCount, group = OwnerAgeGroup, color = OwnerAgeGroup)) +
  geom_line(size = 1) +  # Add line
  geom_point(size = 3) +  # Add points
  geom_hline(yintercept = c(100, 500, 1000, 1500, 2000), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(x = "Year",
       y = "Count of Unique Owner IDs") +
  scale_color_brewer(palette = "Paired") +  # Use color to differentiate lines
  scale_y_continuous(limits = c(0, 2500), breaks = seq(0, 2500, by = 500)) +
  scale_x_continuous(breaks = seq(min(unique_owner_counts$KeyDateYear), max(unique_owner_counts$KeyDateYear), by = 1))  # Define breaks in the x-axis scale to show each year

# Print the plot
ggplotly(p)

```

### 2.2.4. Yearly Dog Counts

After confirming successful conversion, we aggregated the data to compute the total number of dogs per year. The resulting counts were then visualized using histograms to illustrate the distribution over the years.

Furthermore, to understand the trend in dog population over time, we calculated the percentage change between consecutive years. This allowed us to identify any notable fluctuations or patterns in the data.

```{r shiny, yearly dog counts, echo=FALSE, message=FALSE, warning=FALSE}

# Convert NumberOfDogs to numeric
df_EN_EDA <- df_EN_EDA %>% 
  mutate(NumberOfDogs = as.numeric(NumberOfDogs))

# Check for any conversion problems
sum(is.na(df_EN_EDA$NumberOfDogs))

# Convert KeyDateYear to numeric
df_EN_EDA$KeyDateYear <- as.numeric(as.character(df_EN_EDA$KeyDateYear))

# Aggregate data to get total number of dogs per year
yearly_dog_counts <- df_EN_EDA %>%
  group_by(KeyDateYear) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')

# Calculate the percentage change for annotations
yearly_dog_counts <- yearly_dog_counts %>%
  arrange(KeyDateYear) %>%
  mutate(Change = c(NA, diff(TotalDogs)),
         PercentChange = Change / lag(TotalDogs) * 100)

# Define UI
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      helpText("Click on a year in the bar plot to see the percentage change in dog registrations."),
      plotOutput("dogPlot", click = "plot_click"),
      verbatimTextOutput("click_info")
    ),
    mainPanel(
      plotOutput("dogChangePlot")
    )
  )
)

# Define server logic
server <- function(input, output) {
  output$dogPlot <- renderPlot({
    ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
      geom_col(fill = "darkseagreen") +
      geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  
      theme_minimal() +
      labs(title = "Total Number of Dogs per Year",
           x = "Year",
           y = "Total Number of Dogs") +
      scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear, 
                         labels = yearly_dog_counts$KeyDateYear) +  
      scale_y_continuous(labels = scales::comma, 
                         breaks = seq(0, 10000, by = 1000),
                         limits = c(0, 10000)) + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  })
  
  output$click_info <- renderPrint({
    if (!is.null(input$plot_click)) {
      year_clicked <- round(input$plot_click$x)
      year_data <- yearly_dog_counts %>%
        filter(KeyDateYear == year_clicked)
      if (nrow(year_data) > 0) {
        cat("Year:", year_data$KeyDateYear, "\n")
        cat("Total Dogs:", year_data$TotalDogs, "\n")
        cat("Percentage Change:", sprintf("%.1f%%", year_data$PercentChange), "\n")
      } else {
        cat("No data available for the selected year.")
      }
    }
  })
  
  output$dogChangePlot <- renderPlot({
    ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
      geom_col(fill = "darkseagreen") +
      geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  
      geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +  
      geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)), 
                vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
      theme_minimal() +
      labs(title = "Total Number of Dogs per Year",
           x = "Year",
           y = "Total Number of Dogs") +
      scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
      scale_y_continuous(labels = scales::comma, 
                         breaks = seq(0, 10000, by = 1000),  
                         limits = c(0, 10000)) +  
      theme(axis.text.x = element_text(angle = 45, hjust = 1),
            legend.position = "bottom")
  })
}

shinyApp(ui = ui, server = server)

```


### 2.2.5. Heatmap of total number of registered dogs per year 

A heatmap was created to illustrate the distribution of dogs based on the gender and age group of their owners across different years. The data was organized by grouping it according to the year, owner's age group, and gender. Separate heatmaps were generated for each year to visualize the data for that specific period.

Each heatmap represents the total number of dogs in various age groups, categorized by the gender of their owners. The color gradient within the heatmap indicates the intensity of dog ownership, with warmer colors representing higher dog counts.

```{r shiny, heatmap, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            helpText("Displays a heatmap of unique owner counts by age group and gender for the selected year.")
        ),
        mainPanel(
            plotOutput("ownerHeatmap")
        )
    )
)

server <- function(input, output) {
    output$ownerHeatmap <- renderPlot({
        # Filter data for the specific year selected by user
        df_subset <- df_EN_EDA[df_EN_EDA$KeyDateYear == as.numeric(input$selectedYear), ]

        # Prepare the data
        owner_counts <- df_subset %>%
          distinct(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
          group_by(OwnerAgeGroup, OwnerSex) %>%
          summarize(UniqueOwners = n(), .groups = 'drop')

        # Create the heatmap
        p <- ggplot(owner_counts, aes(x = OwnerSex, y = OwnerAgeGroup, fill = UniqueOwners)) +
            geom_tile() +
            scale_fill_gradientn(colors = brewer.pal(11, "Spectral"), 
                                  limits = c(0, max(owner_counts$UniqueOwners, na.rm = TRUE)), 
                                  name = "Total Owners") +
            theme_minimal() +
            labs(title = paste("Heatmap of Unique Owners by Gender and Age Group in", input$selectedYear),
                 x = "Owner's Gender",
                 y = "Owner's Age Group",
                 fill = "Number of Unique Owners") +
            theme(axis.text.y = element_text(angle = 45, hjust = 1))
        
        # Return the plot
        p
    })
}

shinyApp(ui = ui, server = server)

```

### 2.2.6. Total Count of Dogs

#### 2.2.6.1. Total Count of Dogs by District

The annual distribution of dog registrations across various districts is examined using an interactive Shiny application. Users can select a year to view the total count of dogs by district for that specific year. The data is processed and visualized to provide insights into the distribution patterns over time.

```{r shiny, total count of dogs by district, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            helpText("Displays the total count of dogs by district for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter and aggregate data based on the selected year, excluding District 15
        yearly_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(DistrictSort), DistrictSort != "15") %>%
            group_by(DistrictSort) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs))  # Arrange by TotalDogs in descending order

        # Create the bar plot
        p <- ggplot(yearly_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DistrictSort)) +
            geom_col() +
            geom_text(aes(label = TotalDogs), vjust = -0.3, color = "black", size = 3.5) +  # Add dog counts on bars
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d(name = "District") +
            scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1),
                  legend.position = "none")
        
        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.6.2. Total Count of Dogs by District with Dogs'gender

To enhance understanding of the distribution of dogs across different districts and introduce a gender perspective into the analysis, the approach has been modified to include a breakdown by gender. This adjustment allows observation of not only the geographical distribution but also gender dynamics within the dog population each year.

```{r shiny, total count of dogs by district and dogs gender, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", 
                        choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedGender", "Select Gender:",
                        choices = c("All" = "all", "Male" = "male", "Female" = "female")),
            helpText("Displays the total count of dogs by district and gender for the selected year, ordered by total count.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), 
                   !is.na(DistrictSort), 
                   DistrictSort != "15")  # Exclude District 15

        # Apply gender filter if not "All"
        if (input$selectedGender != "all") {
            filtered_data <- filtered_data %>%
                filter(DogSex == input$selectedGender)
        }

        # Aggregate data by district and optionally by gender
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, DogSex) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            ungroup() %>%
            arrange(desc(TotalDogs))  # Order by total dogs in descending order

        # Create the bar plot
        p <- ggplot(yearly_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DogSex)) +
            geom_col(position = position_dodge()) +
            geom_text(aes(label = TotalDogs), vjust = -0.3, color = "black", size = 3.5) +  # Add dog counts on bars
            geom_hline(yintercept = c(100, 500), linetype = "dashed", color = "red") +
            scale_fill_manual(values = c("male" = "darkseagreen", "female" = "salmon")) + 
            scale_y_continuous(limits = c(0, 800), breaks = seq(0, 800, by = 100)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District and Dog gender in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1),
                  legend.position = "bottom")

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.6.3. By district and Unique Owners' gender

This Shiny application provides an interactive visualization of the total count of dogs by district and owner's gender for a selected year. Users can select a year and the gender of the owner to explore the distribution of dogs across different districts, facilitating insights into demographic and geographic trends in dog ownership.

```{r shiny, total count of dogs by unique owners gender, echo=FALSE, message=FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedGender", "Select Owner's gender:", choices = c("Male" = "male", "Female" = "female")),
            helpText("Displays the total count of dogs by district and gender for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(DistrictSort), DistrictSort != "")

        # If 'All' is not selected, further filter by gender
        if (input$selectedGender != "All") {
            filtered_data <- filtered_data %>%
                filter(OwnerSex == input$selectedGender)
        }

        # Aggregate data by district and optionally by gender
        aggregated_data <- filtered_data %>%
            group_by(DistrictSort) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs))

        # Create the plot using reordered DistrictSort based on TotalDogs
        p <- ggplot(aggregated_data, aes(x = reorder(DistrictSort, -TotalDogs), y = TotalDogs, fill = DistrictSort)) +
            geom_col() +
            geom_text(aes(label = TotalDogs), vjust = -0.3) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d() +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District in", input$selectedYear,
                               if(input$selectedGender != "All") paste("—", input$selectedGender) else ""),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1),
                  legend.position = "none")  # Optionally remove the legend

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.6.4. By district and Breed Type

To deepen the analysis of dog populations across different districts annually, the R script incorporates an additional layer of granularity by assessing dog counts not only by district but also by breed type. This enhancement provides a more detailed view of the diversity within the canine populations across various districts each year.

### version 1

```{r shiny, total count of dogs by breedtype, echo=FALSE, message=FALSE, warning=FALSE}

# Define UI
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreedType", "Select Breed Type:", 
                        choices = c("All" = "All", unique(df_EN_EDA$BreedType))),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district and selected breed type for the selected year, excluding District 15.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
        
        # Convert DistrictSort to a factor with levels from 1 to 12
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Optionally include/exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(BreedType != "Unknown")
        }

        # Filter by selected breed type if not 'All'
        if (input$selectedBreedType != "All") {
            filtered_data <- filtered_data %>%
                filter(BreedType == input$selectedBreedType)
        }

        # Aggregate data by district and breed type
        breed_data <- filtered_data %>%
            group_by(DistrictSort, BreedType) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(10, wt = TotalDogs) %>%
            ungroup()

        # Generate the plot
        p <- ggplot(breed_data, aes(x = DistrictSort, y = TotalDogs, fill = BreedType)) +
            geom_col(position = "stack") +
            scale_fill_viridis_d() +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(1700, max(breed_data$TotalDogs, na.rm = TRUE))), breaks = seq(0, 1700, by = 100)) +
            theme_minimal() +
            labs(title = paste("Top 10 Breed Types by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

### version 2

```{r shiny, total count of dogs by breedtype 2, echo=FALSE, message=FALSE, warning=FALSE}

# Define UI
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district and breed type for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on the selected year and handle unknown breed types
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
        
        # Convert DistrictSort to a factor with levels from 1 to 12
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(BreedType != "Unknown")
        }

        # Summarize total dogs by district and breed type
        breed_data <- filtered_data %>%
            group_by(DistrictSort, BreedType) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            ungroup() %>%
            mutate(Position = as.numeric(DistrictSort))  # Position adjustment

        # Create the plot with bars and points
        p <- ggplot() +
            geom_bar(data = breed_data, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
            geom_point(data = breed_data, aes(x = Position, y = TotalDogs, color = BreedType, shape = BreedType), size = 3, position = position_jitterdodge(jitter.width = 0.2)) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d(name = "District", guide = "none") +
            scale_shape_manual(values = seq(1, 20)) +
            scale_size(range = c(1, 6)) +
            scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District in", input$selectedYear),
                 subtitle = "Points indicate count by breed type",
                 x = "District",
                 y = "Total Count of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1))

        return(p)
    })
}

# Run the application
shinyApp(ui = ui, server = server)

```

#### 2.2.6.5. By district, Breed Type and Dogs's Gender

In an effort to provide a more comprehensive analysis of dog populations within various districts, the latest R script has been enhanced to include not only total counts by district but also a detailed breakdown by breed type and gender. This enhancement aims to offer a deeper understanding of the diversity and demographics of canine registrations across different regions.

```{r shiny, total count of dogs by breedtype and dogs gender, echo=FALSE, message = FALSE, warning=FALSE}

# Define UI for the application
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreedType", "Select Breed Type:", choices = c("All", unique(df_EN_EDA$BreedType))),
            selectInput("selectedGender", "Select Gender:", choices = c("All", "Male" = "male", "Female" = "female")),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district, breed type, and gender for the selected year.")
        ),
        mainPanel(
            plotOutput("dogPlot")
        )
    )
)

# Define server logic
server <- function(input, output) {
    output$dogPlot <- renderPlot({
        # Filter data based on the selected year
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
        
        # Convert DistrictSort to a factor with levels from 1 to 12
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Optionally include/exclude unknown breeds
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(BreedType != "Unknown")
        }

        # Filter by selected breed type if not 'All'
        if (input$selectedBreedType != "All") {
            filtered_data <- filtered_data %>%
                filter(BreedType == input$selectedBreedType)
        }

        # Filter by selected gender if not 'All'
        if (input$selectedGender != "All") {
            filtered_data <- filtered_data %>%
                filter(DogSex == input$selectedGender)
        }

        # Calculate total number of dogs per district
        breed_data <- filtered_data %>%
            group_by(DistrictSort, BreedType, DogSex) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            mutate(Position = as.numeric(DistrictSort) + ifelse(DogSex == "female", -0.2, 0.2))  # Position adjustment for clarity

        # Generate the plot
        p <- ggplot() +
            geom_bar(data = breed_data, aes(x = DistrictSort, y = TotalDogs, fill = DistrictSort), stat = "identity") +
            geom_point(data = breed_data, aes(x = Position, y = TotalDogs, color = DogSex, shape = BreedType), size = 3, position = position_jitterdodge(jitter.width = 0.1)) +
            geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
            scale_fill_viridis_d(name = "District", guide = "none") +
            scale_color_manual(values = c("female" = "salmon", "male" = "darkseagreen")) +
            scale_shape_manual(values = seq(1, 20)) +
            scale_y_continuous(limits = c(0, 2000), breaks = seq(0, 2000, by = 500)) +
            theme_minimal() +
            labs(title = paste("Total Count of Dogs by District, Breed, and Gender in", input$selectedYear),
                 subtitle = "Bar: Total Count | Points: Count by Breed and Gender",
                 x = "District",
                 y = "Total Count of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1))

        return(p)
    })
}

# Run the application
shinyApp(ui = ui, server = server)

```

---

### 2.2.7. Top dog breeds

#### 2.2.7.1. Top dog breeds by year

This Shiny application provides a clear and dynamic way to visualize the most popular dog breeds each year, allowing for the inclusion or exclusion of unknown breeds. The color-coding of breeds enhances readability and helps in quickly identifying trends.

```{r shiny, top dog breeds by year, echo=FALSE, message=FALSE, warning=FALSE}

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
    n_breeds <- length(unique(data$PrimaryBreed))
    palette <- scales::hue_pal()(n_breeds)
    breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
    return(breed_color_map)
}


ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by year")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on the selected year
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear))

        # Optionally exclude unknown breeds
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Aggregate data by PrimaryBreed
        breed_data <- filtered_data %>%
            group_by(PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs)) %>%
            slice_max(order_by = TotalDogs, n = 10)

        # Check if breed data is empty
        if (nrow(breed_data) == 0) {
            return(ggplot() +
                   labs(title = "No data available for the selected year or criteria",
                        x = "", y = "") +
                   theme_minimal())
        }

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(breed_data)

        # Generate the plot
        p <- ggplot(breed_data, aes(x = reorder(PrimaryBreed, TotalDogs), y = TotalDogs, fill = PrimaryBreed)) +
            geom_col() +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(250, 500, 750, 1000), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(1250, max(breed_data$TotalDogs, na.rm = TRUE))), breaks = seq(0, max(750, max(breed_data$TotalDogs, na.rm = TRUE)), by = 250)) +
            theme_minimal() +
            labs(title = paste("Top 10 Primary Breeds", input$selectedYear),
                 x = "Primary Breed", y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

shinyApp(ui = ui, server = server)

```

#### 2.2.7.2. Top dog breeds by district

This visualization enables users to explore the distribution of dog breeds across different districts for a selected year. It highlights the top 5 dog breeds in each district, allowing for a detailed understanding of breed trends and distribution patterns.

```{r shiny, primary breeds by district, echo=FALSE, message=FALSE, warning=FALSE}
  
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by district for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15")

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Ensure DistrictSort is a factor with levels correctly ordered
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Aggregate data
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(yearly_data)

        # Generate the plot
        p <- ggplot(yearly_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
            geom_col(position = "stack") +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(150, 300, 450, 600), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(600, max(yearly_data$TotalDogs))), breaks = seq(0, max(600, max(yearly_data$TotalDogs)), by = 300)) +
            theme_minimal() +
            labs(title = paste("Top 5 Primary Breeds by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 90, hjust = 1))

        return(p)
    })
}

shinyApp(ui = ui, server = server)
```

```{r shiny, all primary breeds by district, echo=FALSE, message = FALSE, warning=FALSE}

# Function to assign colors to PrimaryBreed
assign_colors <- function(data) {
    n_breeds <- length(unique(data$PrimaryBreed))
    palette <- scales::hue_pal()(n_breeds)
    breed_color_map <- setNames(palette, unique(data$PrimaryBreed))
    return(breed_color_map)
}

# Define UI for the application
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            selectInput("selectedBreed", "Select Breed Type:", choices = NULL),  # Dynamically populated
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
            helpText("Displays the total count of dogs by district and selected breed type for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

# Define server logic required to draw a plot
server <- function(input, output, session) {
    # Observe the selected year to update breed type options
    observe({
        year_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(PrimaryBreed), DistrictSort != "15") %>%
            group_by(PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(desc(TotalDogs)) %>%
            slice_max(order_by = TotalDogs, n = 10)

        breed_choices <- c("All", year_data$PrimaryBreed)
        updateSelectInput(session, "selectedBreed", choices = breed_choices, selected = breed_choices[1])
    })

    output$breedPlot <- renderPlot({
        # Filter data based on the selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # If 'All' is not selected for breed type, further filter by selected breed type
        if (input$selectedBreed != "All") {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed == input$selectedBreed)
        }
        
        # Ensure DistrictSort is a factor with levels correctly ordered
        filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))

        # Aggregate data by district and breed type
        aggregated_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Assign colors to PrimaryBreed
        breed_color_map <- assign_colors(aggregated_data)

        # Generate the plot
        p <- ggplot(aggregated_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
            geom_col(position = "stack") +
            scale_fill_manual(values = breed_color_map) +
            geom_hline(yintercept = c(100, 250, 500), linetype = "dashed", color = "red") +
            scale_y_continuous(limits = c(0, max(500, max(aggregated_data$TotalDogs))), breaks = seq(0, 500, by = 100)) +
            theme_minimal() +
            labs(title = paste("Top Breeds by Total Count of Dogs in", input$selectedYear),
                 x = "District",
                 y = "Total Number of Dogs") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))

        return(p)
    })
}

# Run the application 
shinyApp(ui = ui, server = server)

```

```{r shiny, treemap, primary breeds by district, echo=FALSE, message = FALSE, warning=FALSE}

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput("selectedYear", "Select Year:", choices = unique(df_EN_EDA$KeyDateYear)),
            checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
            helpText("Displays top dog breeds by district for the selected year.")
        ),
        mainPanel(
            plotOutput("breedPlot")
        )
    )
)

server <- function(input, output) {
    output$breedPlot <- renderPlot({
        # Filter data based on selected year and exclude District 15
        filtered_data <- df_EN_EDA %>%
            filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15")

        # Optionally exclude unknown breeds based on checkbox input
        if (!input$includeUnknown) {
            filtered_data <- filtered_data %>%
                filter(PrimaryBreed != "Unknown")
        }

        # Aggregate data
        yearly_data <- filtered_data %>%
            group_by(DistrictSort, PrimaryBreed) %>%
            summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
            arrange(DistrictSort, desc(TotalDogs)) %>%
            group_by(DistrictSort) %>%
            top_n(5, wt = TotalDogs) %>%
            ungroup()

        # Plotting the treemap
        treemap(yearly_data,
                index = c("DistrictSort", "PrimaryBreed"),
                vSize = "TotalDogs",
                vColor = "TotalDogs",
                title = paste("Top 5 Primary Breeds by Total Count of Dogs in", input$selectedYear),
                palette = "Spectral")
    })
}

shinyApp(ui = ui, server = server)

```

---

## 3. Models

### 3.1. Linear Model: dog age by breed status

#### 3.1.1. Linear Model for hypothesis testing: dog age by breed status

For the first chapter in the machine learning models we begin with a linear model that will test the effect of a categorical variable. To do this we set ourselves the following question: _does the breed status have an effect on the age at which dogs are registered?_

Understanding typical registration ages for different breeds will allow Pet Paradise to target marketing effectively, reaching owners at the right stage of their pet ownership journey. Additionally, these insights can inform strategic inventory management, anticipating demand for breed-specific products and offering tailored advice to enhance customer satisfaction.

In the context of the question at hand, it is worth noting that linear models will not be employed to generate predictions from the provided data. Rather, they will be utilized to determine whether there is a linear correlation between the various states of categorical variables (such as pedigree dog, non-pedigree, etc.) and the response variable, which denotes the age of the dog.

```{r linearmodel_01, include=FALSE}

# Clean import of dataset
df_EN <- read.csv("Datasets/df_EN.csv")

# Removing outliers
df_EN_cleaned <- subset(df_EN, DogAgeGroupSort < 100)
# Setting MixedBreed to factor
df_EN_cleaned$MixedBreed <- factor(df_EN_cleaned$MixedBreed)
# Setting reference to pure breeds
df_EN_cleaned$MixedBreed <- relevel(df_EN_cleaned$MixedBreed, 
                                    ref = "Pedigree dog")

```

To answer this question we will consider the `DogAgeGroupSort` as the response variable, and the different levels of the categorical variable `MixedBreed` as predictors. We now direct our attention to the following set of boxplots showcasing the relevant variables.


```{r linearmodel_boxplots, echo=FALSE, fig.width=10, fig.height=8, fig.align='center'}

# Boxplots
boxplots_ggplot <- ggplot(df_EN_cleaned, aes(x = MixedBreed, y = DogAgeGroupSort, fill = MixedBreed)) +
  geom_boxplot() +
  labs(x = "Mixed Breed Status", y = "Dog Registration Age") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(boxplots_ggplot)

```

Based on the boxplots above, there does seem to be a difference in dog ages based on their breed status. Interestingly, the most extreme outliers are associated with pedigree dogs. We will continue by defining a linear model.

```{r linearmodel_lm01, echo=TRUE}

lm.dogs.1 <- lm(DogAgeGroupSort ~ MixedBreed, data = df_EN_cleaned)
summary(lm.dogs.1)

```

The intercept refers to the pure breed dogs, while the following predictors represent the differences between themselves and the intercept. The summary of the linear model suggests there is strong evidence that the mean age of pedigree dogs is not equal to 0 at the time of registration, with a value of 5.7 years, while the other three breed categories' ages differ significantly from that of pedigree dogs. The most noticeable difference is between pedigree dogs and those whose secondary breed is unknown, with the latter being 1.79 years older.

We follow up this insight by assessing the differences between each of them. 

```{r linearmodel_drop1, echo=TRUE}

drop1 <- drop1(lm.dogs.1, test = "F")
drop1

```

```rverbatim
# Single term deletions

Model:
DogAgeGroupSort ~ MixedBreed
           Df Sum of Sq     RSS    AIC F value    Pr(>F)    
<none>                  1216314 201636                      
MixedBreed  3     19384 1235698 202752  376.93 < 2.2e-16 ***
```

By performing single term deletions and evaluating the resulting statistics of the model, we find that the breed status does indeed have a significant effect on the age of dogs across its different levels, however limiting these observation to one level at a time.

We can further this insight by drawing a General Linear Hypothesis. We will consider all possible pairwise comparisons with a *Tukey Honest Significant Difference Test*.

```{r linearmodel_glth, include=FALSE, warning=FALSE, message=FALSE, error=FALSE, echo=FALSE}

if (!require(multcomp, quietly = TRUE)) {
  install.packages("multcomp")
  library(multcomp)
}

glth.test.1 <- glht(model = lm.dogs.1,
                    linfct = mcp(MixedBreed = "Tukey"))
summary(glth.test.1)

```

```{r linearmodel_glth_plot, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.align='center', include=TRUE, fig.width=10, fig.height=4, cache=TRUE}

par(mar = c(5, 30, 5, 5) + 0.1)  # c(bottom, left, top, right) + 0.1
plot(glth.test.1,
     main = "Tukey Honest Significant Difference Test",
     sub = "95% family-wise confidence level")

```

In the above _Tukey Honest Significant Difference Test_ the similarity between means of different pairs is shown based on how different they are, with closeness to 0 representing no difference in their means. This, along with the 95% confidence intervals, provides an illustrative insight into pairwise variations.

---

#### 3.1.1. Linear Model: dog count over time

As an additional implementation of linear models, we now aim at answering the following research question: _how do dog counts evolve over time?_ To do so we will build a linear model that will provide some information about the trends in the time series of registered dog count data over the time period recorded, as well as some predictions for the following 10 years.

```{r linearmodel2_count, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Declare the new copied dataframe
df_EN_lm <- df_EN_EDA

# Ensure KeyDateYear is numeric
df_EN_lm$KeyDateYear <- as.numeric(as.character(df_EN_lm$KeyDateYear))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_lm %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the linear regression model
lm_model <- lm(TotalDogs ~ DistrictSort + KeyDateYear, data = annual_dog_counts)
summary(lm_model)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(lm_model, newdata = new_data)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, data.frame(new_data, predicted_count = predictions), by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "LM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

---

### 3.2. Generalized Linear Model (Poisson)

#### 3.2.2. Generalized Linear Model: dog count over time

As a second implementation of Generalized Linear Models, we return to the previously introduced research question: _how do dog counts evolve over time?_

```{r GLM_model - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Declare the new copied dataframe
df_EN_glm <- df_EN_EDA

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_glm %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GLM model
glm_model <- glm(TotalDogs ~ KeyDateYear + DistrictSort, data = annual_dog_counts, family = poisson())

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(glm_model, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
df_EN_glm$DistrictSort <- factor(df_EN_glm$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GLM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

---

### 3.3. Generalized Linear Model (Binomial)

We set out to answer the following goal: _Identifying Popular Breeds_.

The model can accurately predict the popularity of different dog breeds based on age and sex.

Pet Paradise can use the model predictions to optimize inventory management by stocking up on products that are likely to be in higher demand based on the popularity of different breeds. For example, if certain breeds are more popular among senior dog owners, Pet Paradise can introduce specialized products such as senior dog food or joint supplements targeted towards that demographic.

``` {r glm_part01, include=FALSE, echo=TRUE}

# Create a new dataframe with the selected variables
df_subset <- df_EN[, c("PrimaryBreed", "DogAgeGroupCd", "DogSexCd")]

# Clean NAs
missing_values <- colSums(is.na(df_subset))
print(missing_values) # no missing values :)

# Summary of DogAgeGroupCd
summary(df_subset$DogAgeGroupCd)
# Output shows max value 999 -> "unkown". We replace it with the average age.
mean_dog_age <- mean(df_subset$DogAgeGroupCd[df_subset$DogAgeGroupCd != 999], na.rm = TRUE)
df_subset <- df_subset %>%
  mutate(DogAgeGroupCd = ifelse(DogAgeGroupCd == 999, mean_dog_age, DogAgeGroupCd))
summary(df_subset$DogAgeGroupCd) 

# Distributions
table(df_subset$DogSexCd)
# The distribution of dog sexes shows there are 35,409 female dogs (coded 2) and 35,558 male dogs (coded 1).
# There's no significant skew towards one sex in the dataset.

# Favourite 5 breeds
breed_counts <- table(df_subset$PrimaryBreed)
sorted_breeds <- sort(breed_counts, decreasing = TRUE)
top_5_breeds <- head(sorted_breeds, 5)
top_5_breeds

```

| Top Breeds         | Unknown   | Chihuahua | Labrador Retriever | Yorkshire Terrier | Jack Russel Terrier |
|--------------------|-----------|-----------|--------------------|-------------------|---------------------|
| Number of Dogs     | 9095      | 4828      | 4198               | 2709              | 2579                |

So Pet Paradise must offer mixed breed foods and products. Not only purebred product offerings.

``` {r glm_part02}

df_EN_subset <- df_EN
df_EN_subset$DogSexCd <- ifelse(df_EN_subset$DogSexCd == "Female", 1, 0)

# Fit the binomial logistic regression model
binomial_model <- glm(DogSexCd ~ DogAgeGroupCd, family = binomial, data = df_EN_subset)

# Summary of the model
summary(binomial_model)

# Odds ratios
exp_coef <- exp(coef(binomial_model))
print(exp_coef)

# Percentage change in odds
percentage_change <- (exp_coef - 1) * 100

# Interpretation of the coefficients
print("Interpretation of Coefficients:")
print(paste("For every increase in dog age group, the odds of being female increase by",
            round(percentage_change["DogAgeGroupCd"], 2), "%"))


```

Older dogs are more likely to be female, if all other variables are equal. Pet Paradise could tailor its pet care,
such as tailoring products or services to the specific needs of aging female dogs. But, the increase is negligible, at 0.35%.

So instead, another sales approach. Let's say, Pet Paradise is trying to target specific age groups for marketing or sales purposes.
Pet Paradise wants to predict the likelihood of a pet owner in their 40s owning a top 5 breed (e.g., the Chihuahua)
compared to owning an unknown breed. For this, a binomial logistic regression makes most sense to use.
This is because the response variable is binary: either a pet owner owns a Chihuahua (let say, coded as 1)
or they own an unknown breed (we will code this as 0).

---

### 3.4. Generalized Additive Model

For the Generalized Additive Model chapter we again direct our attention to the previously introduced research question: _how do dog counts evolve over time?_

As a straightforward implementation of the GAM model, we set ourselves to produce a regression of the registered count data, grouped by districts of the city, analyze their evolution over time, and additionally provide predictions for the next 10 years.

```{r gam_libraries, include=FALSE}

 # GAM
if (!require(mgcv, quietly = TRUE)) {install.packages("mgcv")}
library(mgcv)

if (!require(effects, quietly = TRUE)) {install.packages("effects")}
library(effects)


```

#### 3.4.1. GAM model: dog count over time

```{r gam_model_simple - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

df_EN_gam <- df_EN_EDA

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_EN_gam %>%
  filter(!is.na(DistrictSort)) %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the GAM model with reduced knots
gam_model_simple <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 4) + s(DistrictSort, bs = "re"),
                        data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_simple)

# Predictions
new_data <- data.frame(
  KeyDateYear = c(2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2030, 2040, 2050),
  DistrictSort = factor(rep(1:12, each = 12))
)

# Predict dog counts
predictions <- predict(gam_model_simple, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Adjust DistrictSort to have levels from 1 to 12 as indicated
df_EN_gam$DistrictSort <- factor(df_EN_gam$DistrictSort, levels = as.character(1:12))

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)
head(combined_data)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  #geom_line(aes(y = TotalDogs, color = DistrictSort, group = DistrictSort), size = 0.5) +  # Observed data
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

We now proceed to further omptimize the GAM model.

```{r gam_model_refined - Total Count of Dogs by District Over Years with Predictions, echo=FALSE, message=FALSE, fig.align='center', fig.width=8, fig.height=6, warning=FALSE}

# Create a subset of the data where DistrictSort is a factor
df_subset <- df_EN_gam %>%
  filter(!is.na(DistrictSort)) %>%
  mutate(DistrictSort = factor(DistrictSort, levels = as.character(1:12)))

# Aggregate data to get the total dog count per district per year
annual_dog_counts <- df_subset %>%
  group_by(KeyDateYear, DistrictSort) %>%
  summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
  arrange(KeyDateYear, DistrictSort)

# Fit the simplified GAM model
gam_model_refined <- gam(TotalDogs ~ s(KeyDateYear, bs = "cr", k = 8) +
                         s(DistrictSort, bs = "re"),
                         data = annual_dog_counts, method = "REML", family = poisson(link = "log"))
summary(gam_model_refined)

# Predictions
new_data <- data.frame(
  KeyDateYear = rep(c(2015:2023, 2030, 2040, 2050), each = 12),
  DistrictSort = factor(rep(1:12, times = 12), levels = as.character(1:12))
)

# Predict dog counts
predictions <- predict(gam_model_refined, newdata = new_data, type = "response")
prediction_data <- data.frame(KeyDateYear = new_data$KeyDateYear, DistrictSort = new_data$DistrictSort, predicted_count = predictions)

# Combine observed and predicted data for plotting
combined_data <- merge(annual_dog_counts, prediction_data, by = c("KeyDateYear", "DistrictSort"), all = TRUE)

# Create the line plot
p <- ggplot(combined_data, aes(x = KeyDateYear)) +
  geom_point(aes(y = TotalDogs, color = DistrictSort), size = 2) +  # Observed data points
  geom_line(aes(y = predicted_count, color = DistrictSort, group = DistrictSort), linetype = "solid", size = 0.5) +  # Predicted data
  scale_x_continuous(breaks = unique(combined_data$KeyDateYear)) +  # Ensure each year is shown on the x-axis
  scale_color_viridis_d(name = "District") +
  theme_minimal() +
  xlim(2015, 2030) + 
  ylim(0, 3000) + 
  labs(title = "GAM refined: Total Count of Dogs by District Over Years with Predictions",
       x = "Year",
       y = "Total Number of Dogs") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right")

ggplotly(p)

```

#### 3.4.2. Model comparison

We now look at some comparison now between the above two models, as well as the GLM that was introduced earlier.

```{r gam_comparisons, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}

combined_data <- combined_data

# Create scatterplot for residuals vs fitted values
plot(gam_model_simple$fitted.values, resid(gam_model_simple), col = "darkturquoise", 
     xlab = "Fitted values", ylab = "Residuals", 
     main = "GAM Comparison: Residuals vs Fitted Values", pch = 8)
points(gam_model_refined$fitted.values, resid(gam_model_refined), col = "goldenrod", pch = 8)
points(glm_model$fitted.values, resid(glm_model), col = "darksalmon", pch = 8)
legend("topright", legend = c("GLM", "GAM", "refined GAM"), col = c("darksalmon", "darkturquoise", "goldenrod"), pch = 8)
grid()

```

```{gam_comparisons_2, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}

# Extract and plot the effect of time for a few districts
library(effects)
for(district in unique(combined_data$prediction_count)[1:12]) {
  effect_data <- effect("KeyDateYear", gam_model_refined, xlevels = list(DistrictSort = district))
  effect_df <- as.data.frame(effect_data)

  ggplot(effect_df, aes(x = KeyDateYear, y = fit)) +
    geom_line(shade = TRUE, size = 1) +
    geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
    labs(title = paste("Effect of Year in District", district),
         x = "Year", y = "Fitted TotalDogs Count") +
    theme_minimal()
}

```

```{gam_comparisons_AIC, echo=TRUE, include=FALSE}

# Using AIC for model comparison
aic_comparison <- AIC(gam_model_simple, gam_model_refined)
print(aic_comparison)

```

---

### 3.5. Artificial Neural Network

We start this chapter by posing a research question: _is a dog of pure or mixed breed, based on location and owner and dog’s characteristics?_

An artificial neural network (ANN) is the algorithm of choice for this assessment due to its capability to handle complex, non-linear relationships within the dataset. Dogs' breed may depend on various interacting factors, such as age, size, location, and owner demographics, which ANNs can effectively capture and analyze. 

Their scalability and adaptability make them robust for ongoing studies, while their multilayered learning allows the model to automatically identify the most significant features. We ultimately aim to accurately predict breed status and provide valuable insights for our suggested business project, as well as pet adoption agencies, veterinarians, or even urban planners of the city of Zurich.

Continuing with the development of models, and answering the above, we now look into the implementation of an Artificial Neural Network using the packages `nnet` and `caret` in R. The resulting classification result for the dependent variable will be produced by the model considering variables of both numerical and categorical type.

The target variable `MixedBreed` is of categorical type (factor in R), indicating the dog’s pedigree status, with 4 different possible responses, from pure breed to 3 different descriptors of breed mixing. For the sake of simplicity, the levels within the `MixedBreed` factor variable have been reduced to a binary response, indicating whether the dog is of pure pedigree or not. We consider that this response better fits the information needed for our business case. 

As explained above, the response variables of choice pertain to characteristics of the dog owners (their age, sex, and district), as well as some characteristics of the dogs (dog age and sex). The predictors are the following: `OwnerAgeGroupCd`, `OwnerSexCd`, `DistrictCd`, `DogAgeGroupCd` and `DogSexCd`. Although the model results suggest that incorporating additional predictors should be done to improve the model's accuracy, we have kept the current selection for learning purposes.

The libraries of choice are `nnet` and `caret`, the first one providing the functions for creating and training the model, and the latter providing an interface to further preprocess and train the model. This allowed to implement a 10-fold cross-validation during the training phase of the model building. It also allowed to establish a tune grid with various possible hyperparameters to test out different combinations and find the most optimal ones.

``` {r neuralnetwork_libraries, include=FALSE}

# Install dependencies

# For the ANNs
if (!require(nnet, quietly = TRUE)) {
  install.packages("nnet")
  library(nnet)
}
# For model training and evaluation
if (!require(caret, quietly = TRUE)) {
  install.packages("caret")
  library(caret)
}
# For the visualization
if (!require(gamlss.add, quietly = TRUE)) {
  install.packages("gamlss.add")
  library(gamlss.add)
}
# For the quality assessment
if (!require(ROCR, quietly = TRUE)) {
  install.packages("ROCR")
  library(ROCR)
}

```

```{r neuralnetwork_sampling, include=FALSE}

# Select a subset of variables of interest
variables_net <- c("OwnerAgeGroupCd",
                "OwnerSex", 
                "District",
                "DogAgeGroupCd",
                "DogSex", 
                "MixedBreed")
df_net <- df_EN[variables_net]

#### PREPARATION OF DATA: FACTORS AND SAMPLING ####

# Convert categorical variables to factors
df_net$OwnerAgeGroupCd <- as.integer(df_EN$OwnerAgeGroupCd)  # Keep as numerical
df_net$OwnerSex <- as.factor(df_EN$OwnerSex)
df_net$District <- as.factor(df_EN$District)
df_net$DogAgeGroupCd <- as.integer(df_EN$DogAgeGroupCd)      # Keep as numerical
df_net$DogSex <- as.factor(df_EN$DogSex)
df_net$MixedBreed <- as.factor(df_EN$MixedBreed)             # Response variable

# Creating a new binary target variable from multinomial
# Pedigree dog stays as such, all others are mixed breeds, and set to factor
df_net$BinaryMixedBreed <- ifelse(df_net$MixedBreed == "Pedigree dog",
                                 "Pedigree dog",
                                 "Mixed breed")
df_net$BinaryMixedBreed <- as.factor(df_net$BinaryMixedBreed)
df_net <- df_net[, -which(names(df_net) == "MixedBreed")] # Remove original var.

# Split the data into training and testing sets
# The split is done proportionally for the BinaryMixedBreed variable
set.seed(123)  # for reproducibility
trainIndex <- createDataPartition(df_net$BinaryMixedBreed,
                                  p = 0.8, 
                                  list = FALSE,
                                  times = 1)
df_train <- df_net[trainIndex, ]
df_test <- df_net[-trainIndex, ]

```

``` {r neuralnetwork_train, include=FALSE}

# Cache save location
model_path <- "ML1_Final_Dogs_cache/nnet/breed_net.rds"

if (file.exists(model_path)) {
  # Load the cached model
  breed_net <- readRDS(model_path)
} else {
  
  # Define the control function for training
  train_control <- trainControl(method = "cv", number = 10)
  
  # Hyperparameters
  grid <- expand.grid(size = c(5, 10, 15), decay = c(0.01, 0.001, 0.0001))
  
  set.seed(123)
  # Train neural network model with selected features, hyperparameter tuning
  breed_net <- train(BinaryMixedBreed ~ .,
                      data = df_train,
                      method = "nnet",
                      trControl = train_control,
                      tuneGrid = grid,
                      linout = FALSE,           # For categorical response
                      trace = TRUE,             # To see what's happening live
                      maxit = 10000)            # Max. number of iterations

  # Save the model to disk to ensure it is not re-trained
  saveRDS(breed_net, model_path)
  
}

```

```{r neuralnetwork_print, include=TRUE}

breed_net
breed_net$finalModel

```

```{r neuralnetwork_predict, include=FALSE}

# Make predictions on the test set
predictions_binary <- predict(breed_net, newdata = df_test)
predictions_binary <- factor(predictions_binary)  # Is this necessary?
df_test$BinaryMixedBreed <- factor(df_test$BinaryMixedBreed)

# Generate the confusion matrix
cm_binary <- confusionMatrix(predictions_binary, df_test$BinaryMixedBreed)
cm_binary

# Convert the confusion matrix to a data frame
cm_binary_df <- as.data.frame(cm_binary$table)

# Rename the columns for better readability
colnames(cm_binary_df) <- c("Prediction", "Reference", "Freq")

```

``` {r neuralnetwork_plot, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.align='center'}

#### PLOTTING THE MODEL ####

# Extract the final model
final_model <- breed_net$finalModel
# Plot the neural network
plot(final_model)

```

After running the code, the final model is a neural network with 16 input nodes, 15 hidden nodes, and 1 output node, totalling 271 weights. However, an evaluation of the confusion matrix and ROC curves indicates insufficient evidence to support the model's validity for the given variables. This issue might stem from the selection of variables; expanding the set to include more variables from the dataset might improve the model. Alternatively, it could be that an artificial neural network is not the most suitable model for addressing this particular research question.

```{r neuralnetwork_conf_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}

# Confusion matrix plot
net_ggplot <- ggplot(data = cm_binary_df, aes(x = Reference, y = Prediction, fill = Freq)) +
    geom_tile() +
    scale_fill_gradient(low = "mistyrose", high = "darksalmon") +
    geom_text(aes(label = Freq), vjust = 1) +
    theme_minimal() +
    labs(title = "Binary Confusion Matrix", x = "Reference", y = "Predicted") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(net_ggplot)

```
After building the model with an 80% training subset of the total dataset, we use it to predict values for the remaining 20%. We evaluate the model's performance using a confusion matrix, which allowe us to compare our predicted values with the actual values of the test subset. The model successfully classifies 10,098 dogs as pure-bred, with only 44 being misclassified. However, this good result is overshadowed by the misclassification of 4,020 mixed-breed dogs, with only 31 correct predictions. This suggests that the model wrongly tends to classify most dogs as pure-bred.

```{r neuralnetwork_quality, include=FALSE}

# Switch the type to "prob"
pred_prob <- predict(breed_net,
                    df_test,
                    decision.values=TRUE,
                    type = "prob")

# Extract probabilities of the positive class
pred_prob_positive <- pred_prob[, 2]

# Convert to a numeric vector
pred_numeric <- as.numeric(pred_prob_positive)

# Create the prediction object
pred <- ROCR::prediction(pred_numeric,
                         df_test$BinaryMixedBreed)


```



```{r neuralnetwork_ROC, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.align='center', include=TRUE, fig.width=8, fig.height=6, cache=TRUE}

perf <- ROCR::performance(pred, "tpr", "fpr")
plot(perf, lwd=2, col="darksalmon", main = "ROC Curve")
abline(a=0, b=1)

```

The *ROC Curve* displays a closeness to the diagonal, which raises the possibility that the model’s predictions are not accurate, and support the need to either review the model with more predictors or consider a different model to answer the question at hand altogether.

---

### 3.6. Support Vector Machine Model

---

## 4. Additional chapter

---

## 5. Conclusion

---

## 6. Appendix: Working with generative AI tools