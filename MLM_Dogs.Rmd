---
title: "Machine Learning Methods: a look into the dog register of the city of Zürich"
author: "Rina Gandolfi, Daniel Herrera & Lina Scarborough"
date: "2024-03-01"
output:
  html_document: 
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Presentation of the case

---

## 2. Data exploration

### 2.1. Data source

As mentioned above, the main data has been sourced from the [opendata.swiss project](https://opendata.swiss/de/dataset/hundebestande-der-stadt-zurich-seit-2015/resource/5f8eafd2-367f-489c-a075-42426d14c586), having been collected and published by the Open Data Portal of the City Council of Zürich, under the name "Hundebestände der Stadt Zürich, seit 2015". The description of the data set from the original source is as follows:

_This dataset contains information on dogs and their owners from the municipal dog register since 2015. Information on the age group, gender and statistical district of residence is provided for dog owners. The breed, breed type, sex, year of birth, age and color are recorded for each dog. The dog register is kept by the Dog Control Department of the Zurich City Police._

For the sake of a seamless workflow and easier interpretation of the variables within our group, the names of columns as well as certain string values have been translated to English from the original German version. 

```{r loading, include=FALSE}

setwd("~/GitHub/MachineLearningMethods")

##### LIBRARIES #####
library(tidyverse)
library(ggplot2)
library(sf)
library(mgcv)
library(plotly)
library(corrplot)

##### IMPORTING DATASETS #####

# Importing CSV file
df.dogs <- read.csv("Datasets/kul100od1001.csv")

# Importing city polygons
st.zh <- st_read("Datasets/stzh.adm_stadtkreise_a.geojson")

##### TRANSLATING COLUMN NAMES #####

# TRANSLATION OF COLUMN NAMES

translation_dict <- c("StichtagDatJahr" = "ReferenceYear",
                      "DatenstandCd" = "DataStatusCoded",
                      "HalterId" = "OwnerId",
                      "AlterV10Cd" = "AgeV10Coded",
                      "AlterV10Lang" = "AgeV10Text",
                      "AlterV10Sort" = "AgeV10Sort",
                      "SexCd" = "OwnerSexCoded",
                      "SexLang" = "OwnerSexText",
                      "SexSort" = "SexSort",
                      "KreisCd" = "DistrictCoded",
                      "KreisLang" = "DistrictText",
                      "KreisSort" = "DistrictSort",
                      "QuarCd" = "QuarterCoded",
                      "QuarLang" = "QuarterText",
                      "QuarSort" = "QuarterSort",
                      "Rasse1Text" = "Breed1Text",
                      "Rasse2Text" = "Breed2Text",
                      "RasseMischlingCd" = "MixedBreedCoded",
                      "RasseMischlingLang" = "MixedBreedText",
                      "RasseMischlingSort" = "MixedBreedSort",
                      "RassentypCd" = "BreedTypeCode",
                      "RassentypLang" = "BreedTypeLong",
                      "RassentypSort" = "BreedTypeSort",
                      "GebDatHundJahr" = "DogBirthYear",
                      "AlterVHundCd" = "DogAgeCoded",
                      "AlterVHundLang" = "DogAgeText",
                      "AlterVHundSort" = "DogAgeSort",
                      "SexHundCd" = "DogSexCoded",
                      "SexHundLang" = "DogSexText",
                      "SexHundSort" = "DogSexSort",
                      "HundefarbeText" = "DogColorText",
                      "AnzHunde" = "NumberOfDogs")

# Rename columns using translation dictionary
names(df.dogs) <- sapply(names(df.dogs), function(x) {
  if (x %in% names(translation_dict)) {
    return(translation_dict[x])
  } else {
    return(x)
  }
})

##### CLEANING DATASET #####

# DATA CLEANING

# Setting NAs (AgeV10Coded = 999 years, DogAgeSort = 999)
df.dogs <- df.dogs %>%
  mutate(
    AgeV10Coded = ifelse(AgeV10Coded == 999, NA, AgeV10Coded),
    AlterVHundSort = ifelse(DogAgeSort == 999, NA, DogAgeSort)
  )

# Replacing NAs with averages
avg_AgeV10Coded <- mean(df.dogs$AgeV10Coded, na.rm = TRUE)
rounded_value <- floor(avg_AgeV10Coded / 10) * 10

# Replace NA values with the rounded down value
df.dogs <- df.dogs %>%
  mutate(
    AgeV10Coded = ifelse(is.na(AgeV10Coded), rounded_value, AgeV10Coded),
    AlterVHundSort = ifelse(is.na(AlterVHundSort), rounded_value, AlterVHundSort)
  )


# Remove redundant variables
df.dogs <- df.dogs %>%
  select(-DataStatusCoded, 
         -AgeV10Coded, 
         -AgeV10Sort, 
         -OwnerSexCoded, 
         -SexSort, 
         -DistrictCoded, 
         -DistrictSort, 
         -QuarterCoded, 
         -QuarterSort, 
         -MixedBreedCoded, 
         -MixedBreedSort, 
         -BreedTypeCode, 
         -BreedTypeSort, 
         -DogAgeText, 
         -DogAgeSort, 
         -DogSexCoded, 
         -DogSexSort, 
         -AlterVHundSort)

```

The main source of data is the `kul100od1001.csv` file, which contains a collection of 70,967 listings with 33 variables.

```{r structure, message=FALSE}

dim(df.dogs)
str(df.dogs)

```

As can be seen in the structure of the data, the set comprises several observations of diverse data types. Most variables are expressed three times as different types, as integers (Coded and Sort form), as well as strings (Text). Depending on their implementation in the study they have been selected in one of the three variants, therefore our selection of relevant observations can be summarized as follows:

**Numerical values**:

  - `ReferenceYear`: numerical value for the reference year
  - `OwnerId`: numerical identifier for the owner of the registered dog
  - `AgeV10Sort`: referring to the owner's age as a 10-year category
  - `DogBirthYear`: numerical value for the birth year of the dog
  - `DogAgeSort`: referring to the dog's age at the time of registration
  - `NumberOfDogs`: numerical counter of the dog count for each dog owner 
  
**Binary variables**: !!! Is breed multinomial or factor? !!!

  - `DogSexText`: numerical value indicating two states for the biological sex of the dog
  
**String values**:

  - `DistricText`: the name of each larger district of Zürich according to the official division
  - `QuarterText`: the name of the smaller neighbourhoods which comprise the larger districts
  - `Breed1Text` and `Breed1Text2`: referring to dog race denominations and information
  - `MixedBreedText`: additional information regarding race mixing in the dog
  - `DogColorText`: a descriptive name for the colour of the dog
  - `BreedTypeLong`: referring to the official dog type classification according to the [Zürich Cantonal Law](https://www.zh.ch/content/dam/zhweb/bilder-dokumente/themen/umwelt-tiere/tiere/veterinaeramt/hunde/publikationen/erlaeuterungenzuhuv.pdf)

```{r enrichment, include=FALSE}

# New DogSize column
df.dogs <- df.dogs %>%
  mutate(DogSize = case_when(
    BreedTypeLong == "Kleinwüchsig" ~ "small",
    BreedTypeLong == "Rassentypenliste I" ~ "large",
    BreedTypeLong == "Rassentypenliste II" ~ "banned",
    TRUE ~ NA_character_
  ))

```

The original data set has been complemented with the GEOJSON file `stzh.adm_stadtkreise_a.geojson` for the production of map plots, by merging both data sets with the district name variables, as convened by the City Council of Zürich.

---

### 2.3. Data insights and research questions

Considering that the dataset predominantly consists of categorical observations with minimal quantitative variables, our approach involves segmenting the exploratory analysis into inquiries centered around various count-based groupings. Subsequently, we will match specific models from our study to the research questions and variables that are best suited for their respective capabilities. 
The following insights and plots offer a glimpse into the dataset, unveiling potential research avenues to explore.

#### 2.3.1. Count by owner sex by year

```{r enriching1, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

ownSex_count_year <- df.dogs %>%
  group_by(ReferenceYear, OwnerSexText) %>%
  summarize(count = n())

ggplot(ownSex_count_year,
       aes(x = factor(ReferenceYear),
           y = count,
           fill = OwnerSexText)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  theme_minimal() +
  labs(title = "Registered dogs by owner sex per year",
       fill = "Owner sex") +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "") +
  scale_fill_manual(values = c("männlich" = "lightsalmon2",
                               "weiblich" = "darkseagreen3"))

```

---

#### 2.3.2. Count by dog sex and year

```{r enriching2, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

df.dogsex_count_year <- df.dogs %>%
  group_by(ReferenceYear, DogSexText) %>%
  summarize(count = n())

ggplot(df.dogsex_count_year,
       aes(x = factor(ReferenceYear),
           y = count,
           fill = DogSexText)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  theme_minimal() +
  labs(title = "Registered dogs by dog sex per year",
       fill = "Dog sex",
       labs(x = "Year")) +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "") +
  scale_fill_manual(values = c("männlich" = "lightsalmon2",
                               "weiblich" = "darkseagreen3"))


```

---

#### 2.3.3. Top 10 count by dog breed

```{r enriching3, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

df.dogbreed_count <- df.dogs %>%
  group_by(Breed1Text) %>%
  summarize(count = n())

# Get the top 10 highest counts per dog breed
top_10_dogbreed <- df.dogbreed_count %>%
  top_n(10, wt = count) %>%
  arrange(desc(count))

ggplot(top_10_dogbreed, aes(x = reorder(Breed1Text, -count), y = count)) +
  geom_bar(stat = "identity", fill = "darkgrey") +
  theme_minimal() +
  labs(title = "Top 10 Dog Breeds") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

---

#### 2.3.4. Overall count by owner age group

```{r enriching4, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

ownAge_count <- df.dogs %>%
  group_by(AgeV10Text) %>%
  summarize(count = n())
ownAge_count

ggplot(ownAge_count,
       aes(x = factor(AgeV10Text),
           y = count,
           fill = AgeV10Text)) +
  geom_bar(stat = "identity",
           position = "dodge",
           fill = "darkgrey") +
  theme_minimal() +
  labs(title = "Registered dogs by owner age group",
       fill = "Age group") +
  scale_x_discrete(name = "") +
  scale_y_continuous(name = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

---

#### 2.3.5. Average dog age per district

```{r enriching5, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

# Calculate average dog age by district
average_dog_age <- df.dogs %>%
  group_by(DistrictText) %>%
  summarise(avg_age = mean(DogAgeCoded, na.rm = TRUE))

ggplot(average_dog_age, aes(x = reorder(DistrictText, -avg_age), y = avg_age)) +
  geom_bar(stat = "identity",
           fill = "darkgrey") +
  theme_minimal() +
  labs(title = "Average Dog Age by District",
       x = "",
       y = "Years") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

---

### 2.2. Correlation plot

```{r correlation, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, results='hide', fig.keep='all', fig.width=10, fig.height=6, fig.align='center', cache=FALSE}

##### CORRELATION PLOT #####

# Filter numeric columns
numeric_cols <- select_if(df.dogs, is.numeric)

# Compute correlation matrix
correlation_matrix <- cor(numeric_cols)

# Create a correlation plot using ggcorrplot
corrplot(correlation_matrix)

```

---

## 3. Models

### 3.1. Linear Model: dog count by district over time

```{r model01_plot, include=FALSE}

##### MODEL 01 -- DOG COUNT BY DISTRICT + LINEAR REGRESSIONS #####

dog_count_per_neighborhood_year <- df.dogs %>%
  group_by(DistrictText, ReferenceYear) %>%
  summarize(DogCount = n())

fit01_ggplot <- ggplot(dog_count_per_neighborhood_year, 
       aes(x = ReferenceYear, 
           y = DogCount, 
           color = DistrictText)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Dog registrations by neighborhood - Linear Model",
       x = "",
       y = "",
       color = "District") +
  theme_minimal() +
  scale_x_continuous(breaks = unique(dog_count_per_neighborhood_year$ReferenceYear))

```

```{r model01_plotly, echo=TRUE, fig.width=10, fig.height=6, fig.align='center', cache=TRUE}

ggplotly(fit01_ggplot)

```

```{r model01_fit_coef, echo=TRUE}

lm.counts.year <- lm(DogCount ~ ReferenceYear * DistrictText,
                     data = dog_count_per_neighborhood_year)
summary(lm.counts.year)

```

---

### 3.2. Generalized Linear Model (Poisson)



---

### 3.3. Generalized Linear Model (Binomial)

```{r model03_fit, include=FALSE}

# dog_sex_counts <- df.dogs %>%
#  group_by(DogSexCoded) %>%
#  summarize(count = n())

# Binomial bar plot
# ggplot(dog_sex_counts, aes(x = DogSexCoded, y = count)) +
#  geom_bar(stat = "identity",
#           fill = "lightblue") +
#  labs(title = "Count of Male vs. Female Dogs",
#       x = "Sex",
#       y = "Count") +
#  theme_minimal() +
#  geom_smooth(method = "glm",
#              formula = y ~ x,
#              method.args = list(family = "binomial"))

# Recode DogSexCoded to be binary (1 for female, 0 for male)
#df.dogs$DogSexCoded <- ifelse(df.dogs$DogSexCoded == 2, 1, 0)

# Fit binomial regression model
# binomial_model <- glm(DogSexCoded ~ AgeV10Coded,
#                       data = df.dogs,
#                       family = binomial())

```
```{r model03_coef, echo=TRUE}

# Display summary of the model
#summary(binomial_model)

```


---

### 3.4. Generalized Additive Model (Binomial)

---

### 3.5. Neural Network

---

### 3.6. Support Vector Machine Model

---

### 3.7. Optimisation Problem

---

## 4. Additional chapter

---

## 5. Conclusion

---

## 6. Appendix: Working with generative AI tools