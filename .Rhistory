filter(!is.na(host_id))
# Group all counts of 10 or more into '10+'
listings_per_host$count_grouped <- ifelse(listings_per_host$count > 10,
"10+",
as.character(listings_per_host$count))
# Convert the column to a factor to control the order in the plot
listings_per_host$count_grouped <- factor(listings_per_host$count_grouped,
levels = c(as.character(1:10),
"10+"))
# Create the histogram
ggplot(listings_per_host, aes(x = count_grouped)) +
geom_bar(fill = "#f1796f") +
labs(x = "Listing count",
y = "Number of hosts",
title = "Number of hosts per listing count",
subtitle = "Barcelona") +
theme(axis.text.x = element_text()) +
theme_minimal()
top_hosts <- Barcelona_md %>%
distinct(host_id, .keep_all = TRUE) %>%
arrange(desc(calculated_host_listings_count)) %>%
slice_head(n = 5)
# Create the ggplot2 horizontal barplot
ggplot(top_hosts, aes(x = reorder(host_name, calculated_host_listings_count),
y = calculated_host_listings_count)) +
geom_bar(stat = "identity",
fill = "#f1796f") +
geom_text(aes(label = calculated_host_listings_count),
hjust = 0,
color = "black",
size = 3) +
labs(title = "Top 5 hosts by number of listings",
subtitle = "Barcelona",
x = "",
y = "Listing count") +
coord_flip() + # Flip the plot to horizontal bars
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1))
top_hosts <- Barcelona_md %>%
distinct(host_id, .keep_all = TRUE) %>%
arrange(desc(calculated_host_listings_count)) %>%
slice_head(n = 5)
# Create the ggplot2 horizontal barplot
ggplot(top_hosts, aes(x = reorder(host_name, calculated_host_listings_count),
y = calculated_host_listings_count)) +
geom_bar(stat = "identity",
fill = "#f1796f") +
geom_text(aes(label = calculated_host_listings_count),
hjust = 0,
color = "black",
size = 3) +
labs(title = "Top 5 hosts by number of listings",
subtitle = "Barcelona",
x = "",
y = "Listing count") +
coord_flip() + # Flip the plot to horizontal bars
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1))
knitr::opts_chunk$set(echo = TRUE)
lm(price ~ star_rating, data = Barcelona_md)
data(co2)
data(co2)
co2.stl <- stl(co2, s.window = "periodic")
plot(co2.stl)
# 4) gam.xray -- 16% TRUE ??
xray.gam.acc <- cbind(
predict(gam.xray, type = "response"),
d.xray["disease"]
)
set.seed(10)
##### Packages #####
library(tidyverse)    # Data manipulation and visualization
library(kernlab)      # SVM methodology
library(e1071)        # SVM methodology
library(ISLR)         # Contains example data set
library(RColorBrewer) # Customized colors for plots
# Construct sample data set - completely separated
x <- matrix(rnorm(20*2), ncol = 2)
y <- c(rep(-1,10), rep(1,10))
x[y==1,] <- x[y==1,] + 2
dat <- data.frame(x=x, y=as.factor(y))
# Plot data
ggplot(
data = dat,
aes(x = x.2, y = x.1, color = y, shape = y)
) +
geom_point(size = 2) +
scale_color_manual(values=c("#000000", "#FF0000")) +
theme(legend.position = "none")
## Using the e1071 package
# Fit Support Vector Machine model to data set
svmfit <- svm(
y~., data = dat,
kernel = "linear", scale = FALSE,
cost = 1e10
)
# Plot Results
plot(svmfit, dat)
plot(t.yields)
##### EXERCISE 6.1 #####
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
pacf(t.yields, ylim = c(-1, 1))
## c)
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
r.burg$resid
str(r.burg
str(r.burg)
str(r.burg)
plot(resid)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
plot(resid)
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
##### EXERCISE 6.1 #####
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
pacf(t.yields, ylim = c(-1, 1))
# The exponential decay in the acf shows it may be an AR
# From the pacf we conclude p=1
# Xt − μ = α1(Xt−1 − μ) + Et
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
## c)
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
plot(resid)
par(mfrow = c(1, 2))
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
par(mfrow = c(1, 1))
##### EXERCISE 6.1 #####
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
pacf(t.yields, ylim = c(-1, 1))
# The exponential decay in the acf shows it may be an AR
# From the pacf we conclude p=1
# Xt − μ = α1(Xt−1 − μ) + Et
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
## c)
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
plot(resid)
par(mfrow = c(1, 2))
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
par(mfrow = c(1, 1))
par(mfrow = c(1, 1))
##### EXERCISE 6.1 #####
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
pacf(t.yields, ylim = c(-1, 1))
# The exponential decay in the acf shows it may be an AR
# From the pacf we conclude p=1
# Xt − μ = α1(Xt−1 − μ) + Et
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
## c)
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
par(mfrow = c(1, 1))
plot(resid)
par(mfrow = c(1, 2))
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
par(mfrow = c(1, 1))
## d)
str(r.mle <- ar(t.yields, method = "mle", order.max = 1))
r.mle <- arima(yields, order = c(1, 0, 0), include.mean = T)
r.mle
# The following will indicate if the algorithm has converged
r.mle$code
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
##### EXERCISE 6.1 #####
## a)
yields <- read.table("http://stat.ethz.ch/Teaching/Datasets/WBL/yields.dat",
header = FALSE)
t.yields <- ts(yields[, 1])
# Could the data be generated by an AR-process? What is the order p?
# Look at acf() and pacf()
# We plot the time series
plot(t.yields)
# It seems to be stationary, but mean is not 0 an must be shifted AR(p)
# Let's look at acf and pacf
par(mfrow = c(1, 2))
acf(t.yields, ylim = c(-1, 1))
pacf(t.yields, ylim = c(-1, 1))
# The exponential decay in the acf shows it may be an AR
# From the pacf we conclude p=1
# Xt − μ = α1(Xt−1 − μ) + Et
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
## c)
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
par(mfrow = c(1, 1))
plot(resid)
par(mfrow = c(1, 2))
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
par(mfrow = c(1, 1))
## d)
str(r.mle <- ar(t.yields, method = "mle", order.max = 1))
r.mle <- arima(yields, order = c(1, 0, 0), include.mean = T)
r.mle
# The following will indicate if the algorithm has converged
r.mle$code
# 0 means there has been convergence
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
source("~/HSLU/24.1 Second Semester/W.MSCIDS_RTP02.F24 - Discrete Response, Time Series and Panel Data/Exercises/Exercise_06/Exercise-06.R", echo=TRUE)
## b)
# Using the autocorrelations, compute the Yule-Walker estimate of α by hand.
# Recall the Yule-Walker equation for the estimated autocorrelation function at
# lag 1 reads:
#  ˆρ(1) = α · ˆρ (0)
# Yule Walker equation: p(0) = 1
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
# We execute the following to get α alue at lag = 1.
acf(t.yields, plot = FALSE)
# At lag = 1 it is -0.39
# For order.max use the order p you have detected in a).
r.yw <- ar(t.yields, method = "yw", order.max = 1)
r.yw$ar
# Let's look at the variables of the yw object:
str(r.yw)
# The mean of the distribution is included in it, same as mean(t.yields):
r.yw$x.mean
# Innovation variance:
r.yw$var.pred
# Compute parameters of the AR model using Burg method. Check residuals
r.burg <- ar(t.yields, method = "burg", order.max = 1)
# We look at residuals
resid <- r.burg$resid
# Let's look at the variables of the yw object:
str(r.burg)
par(mfrow = c(1, 1))
plot(resid)
par(mfrow = c(1, 2))
acf(resid, na.action = na.omit)
pacf(resid, na.action = na.omit)
par(mfrow = c(1, 1))
## d)
str(r.mle <- ar(t.yields, method = "mle", order.max = 1))
r.mle <- arima(yields, order = c(1, 0, 0), include.mean = T)
r.mle
# The following will indicate if the algorithm has converged
r.mle$code
install.packages(c("randomForest", "xgboost", "Ckmeans.1d.dp", "ggplot2", "MVA", "ROCR", "mclust", "dbscan"))
install.packages(c("randomForest", "xgboost", "Ckmeans.1d.dp", "ggplot2", "MVA", "ROCR", "mclust", "dbscan"))
install.packages(c("randomForest", "xgboost", "Ckmeans.1d.dp", "ggplot2", "MVA", "ROCR", "mclust", "dbscan"))
install.packages("randomForest")
install.packages("xboost")
install.packages("Ckmeans.1d.dp")
install.packages("MVA")
install.packages("ROCR")
install.packages("mclust")
install.packages("dbscan")
plot(diff(log(AirPassengers), lag=12))
plot(diff(diff(log(AirPassengers), lag=12)))
plot(AirPassengers)
# 11.04.2024
plot(AirPassengers)
# We differenciate to remove trend
plot(diff(log(AirPassengers), lag=12))
plot(diff(diff(log(AirPassengers), lag=12)))
library(fpp)
lsunspot100 <- window(log(sunspotarea), start = 1875,
end = 1974)
install.packages("fpp")
library(fpp)
lsunspot100 <- window(log(sunspotarea), start = 1875,
end = 1974)
fit.ar10 <- arima(lsunspot100, order = c(10, 0, 0))
print(cm_binary)
setwd("~/HSLU/24.1 Second Semester/W.MSCIDS_MPM02.F24 - Applied Machine Learning and Predictive Modelling 1/Project")
print(cm_binary)
setwd("~/GitHub/MachineLearningMethods")
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
install.packages("RColorBrewer")
}
library(RColorBrewer)
# forcats
if (!require(forcats, quietly = TRUE)) {
install.packages("forcats")
}
library(forcats)
# shiny
if (!require(shiny, quietly = TRUE)) {
install.packages("shiny")
}
library(shiny)
# treemap
if (!require(treemap, quietly = TRUE)) {
install.packages("treemap")
}
library(treemap)
# Load dataset
df <- read.csv("Datasets\kul100od1001.csv")
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
