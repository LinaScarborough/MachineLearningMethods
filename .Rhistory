# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
filter(PrimaryBreed %in% top_10_breeds)
# Convert to numeric
df_EN <- df_EN %>%
mutate(DogAge = as.numeric(as.character(DogAgeGroupCd)),
KeyDateYear = as.numeric(as.character(KeyDateYear)))
# Step 1: Identify dogs present in 2015 excluding "Unknown" PrimaryBreed
dogs_in_2015 <- df_EN %>%
filter(KeyDateYear == 2015, PrimaryBreed != "Unknown") %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 2: Identify dogs present in 2023 excluding "Unknown" PrimaryBreed
dogs_in_2023 <- df_EN %>%
filter(KeyDateYear == 2023, PrimaryBreed != "Unknown") %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 3: Intersect the two groups to find dogs present in both years
surviving_dogs <- intersect(dogs_in_2015, dogs_in_2023)
# Now, filter the original dataset for these dogs and years, excluding "Unknown" PrimaryBreed
surviving_dogs_records <- df_EN %>%
filter(PrimaryBreed != "Unknown") %>%
semi_join(surviving_dogs, by = c("OwnerId", "PrimaryBreed", "SecondaryBreed")) %>%
filter(KeyDateYear %in% c(2015, 2023))
# Assuming DogAge is numeric. If not, ensure to convert it first.
# Check for consistent age progression for these dogs
surviving_dogs_age_check <- surviving_dogs_records %>%
arrange(OwnerId, PrimaryBreed, SecondaryBreed, KeyDateYear) %>%
group_by(OwnerId, PrimaryBreed, SecondaryBreed) %>%
summarise(AgeDifference = diff(sort(DogAge)), .groups = 'drop')
# Dogs with consistent age progression, expected to be 8 years apart from 2015 to 2023
consistent_age_progression_2 <- surviving_dogs_age_check %>%
filter(AgeDifference == 8)
# Display the results
print(consistent_age_progression_2)
# Calculate the top 10 breeds based on their occurrence across all years
top_10_breeds <- df_EN %>%
count(PrimaryBreed, sort = TRUE) %>%
slice_max(order_by = n, n = 10) %>% # Correctly select top 10
pull(PrimaryBreed)
# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
filter(PrimaryBreed %in% top_10_breeds)
# Calculate the top 10 breeds based on their occurrence across all years
top_10_breeds <- df_EN %>%
count(PrimaryBreed, sort = TRUE) %>%
slice_max(order_by = n, n = 10) %>% # Correctly select top 10
pull(PrimaryBreed)
# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
filter(PrimaryBreed %in% top_10_breeds)
# Exclude 'Unknown' from the dataset before calculating the top breeds
df_filtered <- df_EN %>%
filter(PrimaryBreed != "Unknown")
# Calculate the top 10 breeds based on their occurrence across all years
top_11_breeds <- df_filtered %>%
count(PrimaryBreed, sort = TRUE) %>%
slice_max(order_by = n, n = 10) %>% # Correctly select top 10 excluding "Unknown"
pull(PrimaryBreed)
# Filter the consistent_age_progression dataset for these top 10 breeds
top_breeds_surviving_dogs <- consistent_age_progression_2 %>%
filter(PrimaryBreed %in% top_11_breeds)
# Pre-calculate the counts for plotting and ordering
top_breeds_counts <- top_breeds_surviving_dogs %>%
count(PrimaryBreed) %>%
arrange(desc(n))
# Visualize the count of surviving dogs from 2015 to 2023 in the top 10 breeds
ggplot(top_breeds_counts, aes(x = reorder(PrimaryBreed, n), y = n, fill = PrimaryBreed)) +
geom_col() +
theme_minimal() +
labs(title = "Aging Dogs from 2015 to 2023 by Top 10 Breeds (Excluding 'Unknown')",
x = "Breed", y = "Count of Surviving Dogs") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_viridis_d() +
theme(legend.position = "none")
# Calculate the top 10 breeds based on their occurrence across all years
top_10_breeds <- df_EN %>%
count(PrimaryBreed, sort = TRUE) %>%
slice_max(order_by = n, n = 10) %>% # Correctly select top 10
pull(PrimaryBreed)
# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
filter(PrimaryBreed %in% top_10_breeds)
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
if (!require(gridExtra, quietly = TRUE)) {
install.packages("rcolorbrewer")
}
library(RColorBrewer)
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
### 3. ENGLISH TRANSLATION ###
# Duplicate and rename df for English version
df_EN <- df
# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
for (i in seq_along(patterns)) {
text <- str_replace_all(text, patterns[i], replacements[i])
}
return(text)
}
# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
# Optional: Print unique values to check the translations
print(unique(df_EN$MixedBreed))
print(unique(df_EN$BreedType))
print(unique(df_EN$DogColor))
View(df_EN)
# Count the occurrences of each OwnerId within each KeyDateYear
owner_repetitions_per_year <- df_EN %>%
group_by(KeyDateYear, OwnerId) %>%
summarize(Count = n(), .groups = 'drop') %>%
filter(Count > 1)  # Keep only those with more than one occurrence in the same year
# Print the results
print(owner_repetitions_per_year)
# This code chunk tracks the aging of dogs from 2015 to 2023, focusing on those with consistent age progression.
# Convert to numeric
df_EN <- df_EN %>%
mutate(DogAge = as.numeric(as.character(DogAgeGroupCd)),
KeyDateYear = as.numeric(as.character(KeyDateYear)))
# Step 1: Identify dogs present in 2015
dogs_in_2015 <- df_EN %>%
filter(KeyDateYear == 2015) %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 2: Identify dogs present in 2023
dogs_in_2023 <- df_EN %>%
filter(KeyDateYear == 2023) %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 3: Intersect the two groups to find dogs present in both years
surviving_dogs <- intersect(dogs_in_2015, dogs_in_2023)
# Filter the original dataset for these dogs and years
surviving_dogs_records <- df_EN %>%
semi_join(surviving_dogs, by = c("OwnerId", "PrimaryBreed", "SecondaryBreed")) %>%
filter(KeyDateYear %in% c(2015, 2023))
# Check for consistent age progression for these dogs
surviving_dogs_age_check <- surviving_dogs_records %>%
group_by(OwnerId, PrimaryBreed, SecondaryBreed) %>%
summarise(AgeDifference = diff(sort(DogAge)))
# Dogs with consistent age progression
consistent_age_progression <- surviving_dogs_age_check %>%
filter(AgeDifference == 8)
print(consistent_age_progression)
# Convert to numeric
df_EN <- df_EN %>%
mutate(DogAge = as.numeric(as.character(DogAgeGroupCd)),
KeyDateYear = as.numeric(as.character(KeyDateYear)))
# Step 1: Identify dogs present in 2015 excluding "Unknown" PrimaryBreed
dogs_in_2015 <- df_EN %>%
filter(KeyDateYear == 2015, PrimaryBreed != "Unknown") %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 2: Identify dogs present in 2023 excluding "Unknown" PrimaryBreed
dogs_in_2023 <- df_EN %>%
filter(KeyDateYear == 2023, PrimaryBreed != "Unknown") %>%
select(OwnerId, PrimaryBreed, SecondaryBreed)
# Step 3: Intersect the two groups to find dogs present in both years
surviving_dogs <- intersect(dogs_in_2015, dogs_in_2023)
# Now, filter the original dataset for these dogs and years, excluding "Unknown" PrimaryBreed
surviving_dogs_records <- df_EN %>%
filter(PrimaryBreed != "Unknown") %>%
semi_join(surviving_dogs, by = c("OwnerId", "PrimaryBreed", "SecondaryBreed")) %>%
filter(KeyDateYear %in% c(2015, 2023))
# Assuming DogAge is numeric. If not, ensure to convert it first.
# Check for consistent age progression for these dogs
surviving_dogs_age_check <- surviving_dogs_records %>%
arrange(OwnerId, PrimaryBreed, SecondaryBreed, KeyDateYear) %>%
group_by(OwnerId, PrimaryBreed, SecondaryBreed) %>%
summarise(AgeDifference = diff(sort(DogAge)), .groups = 'drop')
# Dogs with consistent age progression, expected to be 8 years apart from 2015 to 2023
consistent_age_progression_2 <- surviving_dogs_age_check %>%
filter(AgeDifference == 8)
# Display the results
print(consistent_age_progression_2)
# Calculate the top 10 breeds based on their occurrence across all years
top_10_breeds <- df_EN %>%
count(PrimaryBreed, sort = TRUE) %>%
slice_max(order_by = n, n = 10) %>% # Correctly select top 10
pull(PrimaryBreed)
# Filter the consistent_age_progression dataset for these top 10 breeds
# Ensure that consistent_age_progression is the correct dataset reflecting dogs from 2015 to 2023.
top_breeds_surviving_dogs <- consistent_age_progression %>%
filter(PrimaryBreed %in% top_10_breeds)
# Pre-calculate the counts for plotting and ordering
top_breeds_counts <- top_breeds_surviving_dogs %>%
count(PrimaryBreed) %>%
arrange(desc(n))
# Visualize the count of surviving dogs from 2015 to 2023 in the top 10 breeds
ggplot(top_breeds_counts, aes(x = reorder(PrimaryBreed, n), y = n, fill = PrimaryBreed)) +
geom_col() +
theme_minimal() +
labs(title = "Surviving Dogs from 2015 to 2023 by Top 10 Breeds",
x = "Breed", y = "Count of Surviving Dogs") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_viridis_d() +
theme(legend.position = "none")
df_EN <- df_EN %>%
mutate(NumberOfDogs = as.numeric(NumberOfDogs))
# Check for any conversion problems
sum(is.na(df_EN$NumberOfDogs))
df_EN$KeyDateYear <- as.numeric(as.character(df_EN$KeyDateYear))
# Aggregate data to get total number of dogs per year
yearly_dog_counts <- df_EN %>%
group_by(KeyDateYear) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
print(yearly_dog_counts)
# Create the histogram
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "skyblue", color = "black") +  # Using geom_col for clarity
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear,
labels = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
### Calculate the PERCENTAGE CHANGE for annotations ###
yearly_dog_counts <- yearly_dog_counts %>%
arrange(KeyDateYear) %>%
mutate(Change = c(NA, diff(TotalDogs)),
PercentChange = Change / lag(TotalDogs) * 100)
# Create the base plot
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "skyblue", color = "black") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  # Dashed lines at specified counts
geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +  # Add a linear trend line
geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)),
vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),  # Adjust y-axis to have units of 1000
limits = c(0, 10000)) +  # Ensure y-axis goes up to 10000
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom")
# Convert KeyDateYear and NumberOfDogs to numeric
df_EN$KeyDateYear <- as.numeric(as.character(df_EN$KeyDateYear))
df_EN$NumberOfDogs <- as.numeric(df_EN$NumberOfDogs)
# Aggregate data to get the total number of dogs per year for each gender
yearly_dog_counts_by_gender <- df_EN %>%
group_by(KeyDateYear, OwnerSex) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
print(yearly_dog_counts_by_gender)
# Create histograms for male and female owners with dodging
ggplot(yearly_dog_counts_by_gender, aes(x = KeyDateYear, y = TotalDogs, fill = OwnerSex)) +
geom_bar(stat = "identity", position = position_dodge()) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year by Owner's Gender",
x = "Year",
y = "Total Number of Dogs") +
scale_fill_manual(values = c("male" = "blue", "female" = "pink")) +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  # Dashed lines at specific counts
scale_y_continuous(labels = scales::comma,
breaks = seq(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE), by = 1000),  # Adjust y-axis to have units of 1000
limits = c(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE) + 1000)) +  # Set y-axis limits
scale_x_continuous(breaks = yearly_dog_counts_by_gender$KeyDateYear,
labels = yearly_dog_counts_by_gender$KeyDateYear) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Convert KeyDateYear and NumberOfDogs to numeric
df_EN$KeyDateYear <- as.numeric(as.character(df_EN$KeyDateYear))
df_EN$NumberOfDogs <- as.numeric(df_EN$NumberOfDogs)
# Aggregate data to get the total number of dogs per year for each gender
yearly_dog_counts_by_gender <- df_EN %>%
group_by(KeyDateYear, OwnerSex) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
print(yearly_dog_counts_by_gender)
# Create histograms for male and female owners with dodging
ggplot(yearly_dog_counts_by_gender, aes(x = KeyDateYear, y = TotalDogs, fill = OwnerSex)) +
geom_bar(stat = "identity", position = position_dodge()) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year by Owner's Gender",
x = "Year",
y = "Total Number of Dogs") +
scale_fill_manual(values = c("male" = "blue", "female" = "pink")) +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +  # Dashed lines at specific counts
scale_y_continuous(labels = scales::comma,
breaks = seq(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE), by = 1000),  # Adjust y-axis to have units of 1000
limits = c(0, max(yearly_dog_counts_by_gender$TotalDogs, na.rm = TRUE) + 1000)) +  # Set y-axis limits
scale_x_continuous(breaks = yearly_dog_counts_by_gender$KeyDateYear,
labels = yearly_dog_counts_by_gender$KeyDateYear) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Step 1: Count each owner once per year regardless of the number of dogs
yearly_dog_counts_by_gender_unique <- df_EN %>%
select(KeyDateYear, OwnerId, OwnerSex) %>%
distinct(KeyDateYear, OwnerId, OwnerSex) %>%
group_by(KeyDateYear, OwnerSex) %>%
summarize(UniqueOwners = n(), .groups = 'drop')
print(yearly_dog_counts_by_gender_unique)
# Step 2: Create histograms for male and female owners without repetition
ggplot(yearly_dog_counts_by_gender_unique, aes(x = KeyDateYear, y = UniqueOwners, fill = OwnerSex)) +
geom_bar(stat = "identity", position = position_dodge()) +
theme_minimal() +
labs(title = "Unique Owners per Year by Gender",
x = "Year",
y = "Number of Unique Owners") +
scale_fill_manual(values = c("male" = "blue", "female" = "pink")) +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
scale_y_continuous(labels = scales::comma) +
scale_x_continuous(breaks = yearly_dog_counts_by_gender_unique$KeyDateYear) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Prepare the data
df_EN$OwnerSex <- factor(df_EN$OwnerSex, levels = c("female", "male"))
agg_data <- df_EN %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
# Loop through each year and create a separate plot
years <- unique(agg_data$KeyDateYear)
for (year in years) {
yearly_data <- filter(agg_data, KeyDateYear == year)
# Create the heatmap for the year
p <- ggplot(yearly_data, aes(x = OwnerSex, y = OwnerAgeGroup, fill = TotalDogs)) +
geom_tile() +
scale_fill_viridis_c(option = "D", limits = c(0, 2000), name = "Total Dogs") +  # Fixed scale max at 2000
theme_minimal() +
labs(title = paste("Heatmap of Number of Dogs by Owner's Gender and Age Group in", year),
x = "Owner's Gender",
y = "Owner's Age Group",
fill = "Total Number of Dogs") +
theme(axis.text.y = element_text(angle = 45, hjust = 1))
# Display the plot
print(p)
}
# Adjust the aggregation to count each owner once per age group and gender, per year
owner_counts <- df_EN %>%
select(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
distinct() %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarize(UniqueOwners = n(), .groups = 'drop')
# Loop through each year and create a heatmap
years <- unique(owner_counts$KeyDateYear)
for (year in years) {
yearly_data <- filter(owner_counts, KeyDateYear == year)
p <- ggplot(yearly_data, aes(x = OwnerSex, y = OwnerAgeGroup, fill = UniqueOwners)) +
geom_tile() +
scale_fill_gradientn(colors = brewer.pal(11, "Spectral"), limits = c(0, 2000), name = "Total Dogs") +
theme_minimal() +
labs(title = paste("Heatmap of Unique Owners by Gender and Age Group in", year),
x = "Owner's Gender",
y = "Owner's Age Group",
fill = "Number of Unique Owners") +
theme(axis.text.y = element_text(angle = 45, hjust = 1))
print(p)
}
# Prepare datasets
female_owners_age_group <- df_EN %>%
filter(OwnerSex == "female") %>%
group_by(OwnerAgeGroup) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
mutate(OwnerSex = "Female") # Add gender indication
male_owners_age_group <- df_EN %>%
filter(OwnerSex == "male") %>%
group_by(OwnerAgeGroup) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
mutate(OwnerSex = "Male") # Add gender indication
# Combine the datasets
combined_data <- bind_rows(female_owners_age_group, male_owners_age_group)
ggplot(combined_data, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerSex, OwnerAgeGroup, TotalDogs, sep = "\n"),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", size=15, grow = TRUE) +
scale_fill_gradient(low = "lightblue", high = "steelblue", name = "Total Dogs") +  # Gradient from light to dark blue
labs(title = "Treemap of Number of Dogs Owned Across Age Groups by Gender",
subtitle = "Size of area represents the total number of dogs",
caption = "From 2015 to 2023") +
theme(legend.position = "none")
# Create treemaps for FEMALE AND MALE SEPARATELY
female_treemap <- ggplot(female_owners_age_group, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
scale_fill_gradient(low = "lightpink", high = "darkred", name = "Total Dogs") +
labs(title = "Treemap of Number of Dogs Owned by Female Owners",
subtitle = "Size of area represents the total number of dogs",
caption = "From 2015 to 2023") +
theme(legend.position = "none")
male_treemap <- ggplot(male_owners_age_group, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerAgeGroup, TotalDogs, sep = "\n"),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Total Dogs") +
labs(title = "Treemap of Number of Dogs Owned by Male Owners",
subtitle = "Size of area represents the total number of dogs",
caption = "From 2015 to 2023") +
theme(legend.position = "none")
# Arrange the treemaps side by side using patchwork
female_treemap + male_treemap
# Prepare datasets
female_owners_age_group_unique <- df_EN %>%
filter(OwnerSex == "female") %>%
group_by(KeyDateYear, OwnerId, OwnerAgeGroup) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
mutate(OwnerSex = "Female") # Add gender indication
male_owners_age_group_unique <- df_EN %>%
filter(OwnerSex == "male") %>%
group_by(KeyDateYear, OwnerId, OwnerAgeGroup) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
mutate(OwnerSex = "Male") # Add gender indication
# Combine the datasets
combined_data_unique <- bind_rows(female_owners_age_group_unique, male_owners_age_group_unique)
ggplot(combined_data_unique, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerSex, OwnerAgeGroup, TotalDogs, sep = "\n"),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", size=15, grow = TRUE) +
scale_fill_gradient(low = "lightblue", high = "steelblue", name = "Total Dogs") +  # Gradient from light to dark blue
labs(title = "Treemap of Number of Dogs Owned Across Age Groups by Gender",
subtitle = "Size of area represents the total number of dogs",
caption = "From 2015 to 2023") +
theme(legend.position = "none")
df_EN$NumberOfDogs <- as.numeric(df_EN$NumberOfDogs)
# Aggregate data by KeyDateYear, OwnerAgeGroup, and OwnerSex
agg_data_yearly <- df_EN %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
mutate(YearGroup = as.factor(KeyDateYear)) # Adding YearGroup for plotting
# Get a list of unique years to iterate over
years <- unique(agg_data_yearly$KeyDateYear)
# Loop through each year and create separate treemaps for each gender, then combine them
for (year in years) {
yearly_data_female <- filter(agg_data_yearly, KeyDateYear == year, OwnerSex == "female")
yearly_data_male <- filter(agg_data_yearly, KeyDateYear == year, OwnerSex == "male")
female_treemap <- ggplot(yearly_data_female, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerAgeGroup, "\n", TotalDogs),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
scale_fill_gradient(low = "lightpink", high = "darkred") +
labs(title = paste("Female - Year:", year),
subtitle = "Size of area represents the total number of dogs") +
theme(legend.position = "none")
male_treemap <- ggplot(yearly_data_male, aes(area = TotalDogs, fill = TotalDogs,
label = paste(OwnerAgeGroup, "\n", TotalDogs),
subgroup = OwnerSex)) +
geom_treemap() +
geom_treemap_text(fontface = "italic", colour = "white", place = "centre", grow = TRUE) +
scale_fill_gradient(low = "lightblue", high = "darkblue") +
labs(title = paste("Male - Year:", year),
subtitle = "Size of area represents the total number of dogs") +
theme(legend.position = "none")
# Arrange the treemaps side by side using patchwork
combined_treemap <- female_treemap + male_treemap
print(combined_treemap) # Display the combined plot
}
