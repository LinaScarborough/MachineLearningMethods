ui <- fluidPage(
titlePanel("Top Dog Breeds by District"),
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:", choices = unique(new_df$KeyDateYear)),
selectInput("selectedBreed", "Select Breed Type:", choices = NULL),  # Dynamically populated
checkboxInput("includeUnknown", "Include Unknown Breeds", value = FALSE),
helpText("Displays the total count of dogs by district and selected breed type for the selected year.")
),
mainPanel(
plotOutput("breedPlot")
)
)
)
# Define server logic required to draw a plot
server <- function(input, output, session) {
# Observe the selected year to update breed type options
observe({
year_data <- new_df %>%
filter(KeyDateYear == as.numeric(input$selectedYear), !is.na(PrimaryBreed), DistrictSort != "15") %>%
group_by(PrimaryBreed) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
arrange(desc(TotalDogs)) %>%
slice_max(order_by = TotalDogs, n = 10)
breed_choices <- c("All", year_data$PrimaryBreed)
updateSelectInput(session, "selectedBreed", choices = breed_choices, selected = breed_choices[1])
})
output$breedPlot <- renderPlot({
# Filter data based on the selected year and exclude District 15
filtered_data <- new_df %>%
filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15", !is.na(DistrictSort))
# Optionally exclude unknown breeds based on checkbox input
if (!input$includeUnknown) {
filtered_data <- filtered_data %>%
filter(PrimaryBreed != "Unknown")
}
# If 'All' is not selected for breed type, further filter by selected breed type
if (input$selectedBreed != "All") {
filtered_data <- filtered_data %>%
filter(PrimaryBreed == input$selectedBreed)
}
# Ensure DistrictSort is a factor with levels correctly ordered
filtered_data$DistrictSort <- factor(filtered_data$DistrictSort, levels = as.character(1:12))
# Aggregate data by district and breed type
aggregated_data <- filtered_data %>%
group_by(DistrictSort, PrimaryBreed) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
arrange(DistrictSort, desc(TotalDogs)) %>%
group_by(DistrictSort) %>%
top_n(5, wt = TotalDogs) %>%
ungroup()
# Assign colors to PrimaryBreed
breed_color_map <- assign_colors(aggregated_data)
# Generate the plot
p <- ggplot(aggregated_data, aes(x = DistrictSort, y = TotalDogs, fill = PrimaryBreed)) +
geom_col(position = "stack") +
scale_fill_manual(values = breed_color_map) +
geom_hline(yintercept = c(100, 250, 500), linetype = "dashed", color = "red") +
scale_y_continuous(limits = c(0, max(500, max(aggregated_data$TotalDogs))), breaks = seq(0, 500, by = 100)) +
theme_minimal() +
labs(title = paste("Top Breeds by Total Count of Dogs in", input$selectedYear),
x = "District",
y = "Total Number of Dogs") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
return(p)
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Chunk 22: shiny
ui <- fluidPage(
titlePanel("Dog Breed Trends by District"),
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:", choices = unique(new_df$KeyDateYear)),
checkboxInput("includeUnknown", "Include Unknown Breeds", value = TRUE),
helpText("Displays top dog breeds by district for the selected year.")
),
mainPanel(
plotOutput("breedPlot")
)
)
)
server <- function(input, output) {
output$breedPlot <- renderPlot({
# Filter data based on selected year and exclude District 15
filtered_data <- new_df %>%
filter(KeyDateYear == as.numeric(input$selectedYear), DistrictSort != "15")
# Optionally exclude unknown breeds based on checkbox input
if (!input$includeUnknown) {
filtered_data <- filtered_data %>%
filter(PrimaryBreed != "Unknown")
}
# Aggregate data
yearly_data <- filtered_data %>%
group_by(DistrictSort, PrimaryBreed) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop') %>%
arrange(DistrictSort, desc(TotalDogs)) %>%
group_by(DistrictSort) %>%
top_n(5, wt = TotalDogs) %>%
ungroup()
# Plotting the treemap
treemap(yearly_data,
index = c("DistrictSort", "PrimaryBreed"),
vSize = "TotalDogs",
vColor = "TotalDogs",
title = paste("Top 5 Primary Breeds by Total Count of Dogs in", input$selectedYear),
palette = "Spectral")
})
}
shinyApp(ui = ui, server = server)
# Chunk 23: linearmodel
dog_count_per_neighborhood_year <- df_EN %>%
group_by(District, KeyDateYear) %>%
summarize(DogCount = n())
fit01_ggplot <- ggplot(dog_count_per_neighborhood_year,
aes(x = as.numeric(KeyDateYear),
y = DogCount,
color = District)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Dog registrations by neighborhood - Linear Model",
x = "",
y = "",
color = "District") +
theme_minimal() +
scale_x_continuous(breaks = unique(as.numeric(dog_count_per_neighborhood_year$KeyDateYear)))
# Chunk 24: model01_plotly
dog_count_per_neighborhood_year$KeyDateYear <- as.numeric(as.character(dog_count_per_neighborhood_year$KeyDateYear))
ggplotly(fit01_ggplot)
# Chunk 25: model01_fit_coef
lm.counts.year <- lm(DogCount ~ KeyDateYear * District,
data = dog_count_per_neighborhood_year)
summary(lm.counts.year)
# Chunk 26: neuralnetwork_libraries
# Install dependencies
# For the ANNs
if (!require(nnet, quietly = TRUE)) {
install.packages("nnet")
library(nnet)
}
# For model training and evaluation
if (!require(caret, quietly = TRUE)) {
install.packages("caret")
library(caret)
}
# For the visualization
if (!require(gamlss.add, quietly = TRUE)) {
install.packages("gamlss.add")
library(gamlss.add)
}
# For the quality assessment
if (!require(ROCR, quietly = TRUE)) {
install.packages("ROCR")
library(ROCR)
}
# Chunk 27: neuralnetwork_sampling
# Select a subset of variables of interest
variables_net <- c("OwnerAgeGroupCd",
"OwnerSex",
"District",
"DogAgeGroupCd",
"DogSex",
"MixedBreed")
df_net <- df_EN[variables_net]
#### PREPARATION OF DATA: FACTORS AND SAMPLING ####
# Convert categorical variables to factors
df_net$OwnerAgeGroupCd <- as.integer(df_EN$OwnerAgeGroupCd)  # Keep as numerical
df_net$OwnerSex <- as.factor(df_EN$OwnerSex)
df_net$District <- as.factor(df_EN$District)
df_net$DogAgeGroupCd <- as.integer(df_EN$DogAgeGroupCd)      # Keep as numerical
df_net$DogSex <- as.factor(df_EN$DogSex)
df_net$MixedBreed <- as.factor(df_EN$MixedBreed)             # Response variable
# Creating a new binary target variable from multinomial
# Pedigree dog stays as such, all others are mixed breeds, and set to factor
df_net$BinaryMixedBreed <- ifelse(df_net$MixedBreed == "Pedigree dog",
"Pedigree dog",
"Mixed breed")
df_net$BinaryMixedBreed <- as.factor(df_net$BinaryMixedBreed)
df_net <- df_net[, -which(names(df_net) == "MixedBreed")] # Remove original var.
# Split the data into training and testing sets
# The split is done proportionally for the BinaryMixedBreed variable
set.seed(123)  # for reproducibility
trainIndex <- createDataPartition(df_net$BinaryMixedBreed,
p = 0.8,
list = FALSE,
times = 1)
df_train <- df_net[trainIndex, ]
df_test <- df_net[-trainIndex, ]
# Chunk 1: setup
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
install.packages("RColorBrewer")
}
library(RColorBrewer)
# forcats
if (!require(forcats, quietly = TRUE)) {
install.packages("forcats")
}
library(forcats)
# shiny
if (!require(shiny, quietly = TRUE)) {
install.packages("shiny")
}
library(shiny)
# treemap
if (!require(treemap, quietly = TRUE)) {
install.packages("treemap")
}
library(treemap)
# Chunk 2: loading
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
# Chunk 3: translation
# Duplicate and rename df for English version
df_EN <- df
# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
for (i in seq_along(patterns)) {
text <- str_replace_all(text, patterns[i], replacements[i])
}
return(text)
}
# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
# Optional: Print unique values to check the translations
print(unique(df_EN$MixedBreed))
print(unique(df_EN$BreedType))
print(unique(df_EN$DogColor))
write.csv(df_EN, "df_EN.csv", row.names = FALSE)
# Chunk 4: df_unique_OwnerId
df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
head(df_EN)
# Chunk 5: new_df
# Create a new DataFrame with selected columns and convert 'NumberOfDogs' to numeric
new_df <- df_EN %>%
select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear, DogAgeGroupCd, DogSex, NumberOfDogs, unique_OwnerId) %>%
mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs)))
head(new_df, 5)
# Chunk 6: structure
# Load dataset
str(df_EN)
# Chunk 7: unique_years
# Extract and count unique years
unique_years <- unique(new_df$KeyDateYear)
number_of_unique_years <- length(unique_years)
print(number_of_unique_years)
print(unique_years)
# Chunk 8: unique_OwnerId
# Extract and count unique Owner IDs
unique_Owner <- unique(new_df$OwnerId)
number_of_unique_Owner <- length(unique_Owner)
print(number_of_unique_Owner)
# Chunk 9: shiny
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:",
choices = unique(new_df$KeyDateYear)),
selectInput("selectedGender", "Select Gender:",
choices = c("All" = "all", "Male" = "male", "Female" = "female")),
helpText("Displays unique owner IDs by age group and selected gender for the chosen year.")
),
mainPanel(
plotOutput("genderPlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$genderPlot <- renderPlot({
# Aggregate unique Owner IDs by Age Group, Year, and Gender
if (input$selectedGender == "all") {
# Sum across both genders
unique_owner_counts_gender <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop')
} else {
# Filter for a specific gender
unique_owner_counts_gender <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop') %>%
filter(OwnerSex == input$selectedGender)
}
# Adjust factor levels
unique_owner_counts_gender$OwnerAgeGroup <- factor(unique_owner_counts_gender$OwnerAgeGroup,
levels = unique(new_df$OwnerAgeGroup[order(new_df$OwnerAgeGroup)]))
# Filter data for the specific year
data_for_year_gender <- filter(unique_owner_counts_gender, KeyDateYear == as.numeric(input$selectedYear))
# Create the plot
ggplot(data_for_year_gender, aes(x = OwnerAgeGroup, y = UniqueOwnerCountGender, fill = OwnerAgeGroup)) +
geom_bar(stat = "identity", position = "dodge") +
geom_text(aes(label = UniqueOwnerCountGender), vjust = -0.5, color = "black", size = 3.5) +
geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = paste("Unique Owner IDs by Age Group and", input$selectedGender, "in", input$selectedYear),
x = "Owner Age Group",
y = "Count of Unique Owner IDs") +
scale_fill_brewer(palette = "Paired") +
scale_y_continuous(limits = c(0, max(2000, max(data_for_year_gender$UniqueOwnerCountGender) + 500)), breaks = seq(0, 2000, by = 500)) +
scale_x_discrete(labels = function(x) {
x <- gsub("[0-9]+ to [0-9]+ years old", "", x)
gsub("Unknown", "", x)
})
})
}
shinyApp(ui = ui, server = server)
# Chunk 10: cs seasonal trend of Age Group
# Aggregate unique Owner IDs by Age Group and Year
unique_owner_counts <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCount = n_distinct(OwnerId), .groups = 'drop')
# Adjust factor levels in the aggregated data before plotting
unique_owner_counts <- unique_owner_counts %>%
arrange(desc(UniqueOwnerCount)) %>%
mutate(OwnerAgeGroup = fct_inorder(OwnerAgeGroup),
KeyDateYear = as.numeric(as.character(KeyDateYear)))  # Convert KeyDateYear to numeric
# Create the line plot for all years with a line per age group
p <- ggplot(unique_owner_counts, aes(x = KeyDateYear, y = UniqueOwnerCount, group = OwnerAgeGroup, color = OwnerAgeGroup)) +
geom_line(size = 1) +  # Add line
geom_point(size = 3) +  # Add points
geom_hline(yintercept = c(100, 500, 1000, 1500, 2000), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Unique Owner IDs by Age Group Over Years",
x = "Year",
y = "Count of Unique Owner IDs") +
scale_color_brewer(palette = "Paired") +  # Use color to differentiate lines
scale_y_continuous(limits = c(0, 2500), breaks = seq(0, 2500, by = 500)) +
scale_x_continuous(breaks = seq(min(unique_owner_counts$KeyDateYear), max(unique_owner_counts$KeyDateYear), by = 1))  # Define breaks in the x-axis scale to show each year
# Print the plot
print(p)
# Chunk 11: shiny
# Convert NumberOfDogs to numeric
new_df <- new_df %>%
mutate(NumberOfDogs = as.numeric(NumberOfDogs))
# Check for any conversion problems
sum(is.na(new_df$NumberOfDogs))
# Convert KeyDateYear to numeric
new_df$KeyDateYear <- as.numeric(as.character(new_df$KeyDateYear))
# Aggregate data to get total number of dogs per year
yearly_dog_counts <- new_df %>%
group_by(KeyDateYear) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
# Calculate the percentage change for annotations
yearly_dog_counts <- yearly_dog_counts %>%
arrange(KeyDateYear) %>%
mutate(Change = c(NA, diff(TotalDogs)),
PercentChange = Change / lag(TotalDogs) * 100)
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
helpText("Click on a year in the bar plot to see the percentage change in dog registrations."),
plotOutput("dogPlot", click = "plot_click"),
verbatimTextOutput("click_info")
),
mainPanel(
plotOutput("dogChangePlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$dogPlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear,
labels = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
output$click_info <- renderPrint({
if (!is.null(input$plot_click)) {
year_clicked <- round(input$plot_click$x)
year_data <- yearly_dog_counts %>%
filter(KeyDateYear == year_clicked)
if (nrow(year_data) > 0) {
cat("Year:", year_data$KeyDateYear, "\n")
cat("Total Dogs:", year_data$TotalDogs, "\n")
cat("Percentage Change:", sprintf("%.1f%%", year_data$PercentChange), "\n")
} else {
cat("No data available for the selected year.")
}
}
})
output$dogChangePlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +
geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)),
vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom")
})
}
shinyApp(ui = ui, server = server)
# Chunk 12: shiny
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:",
choices = unique(new_df$KeyDateYear)),
helpText("Displays a heatmap of unique owner counts by age group and gender for the selected year.")
),
mainPanel(
plotOutput("ownerHeatmap")
)
)
)
server <- function(input, output) {
output$ownerHeatmap <- renderPlot({
# Prepare the data
owner_counts <- new_df %>%
select(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
distinct(KeyDateYear, OwnerAgeGroup, OwnerSex, OwnerId) %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarize(UniqueOwners = n(), .groups = 'drop')
# Filter data for the specific year selected by user
yearly_data <- filter(owner_counts, KeyDateYear == as.numeric(input$selectedYear))
# Create the heatmap
p <- ggplot(yearly_data, aes(x = OwnerSex, y = OwnerAgeGroup, fill = UniqueOwners)) +
geom_tile() +
scale_fill_gradientn(colors = brewer.pal(11, "Spectral"), limits = c(0, max(yearly_data$UniqueOwners, na.rm = TRUE)), name = "Total Owners") +
theme_minimal() +
labs(title = paste("Heatmap of Unique Owners by Gender and Age Group in", input$selectedYear),
x = "Owner's Gender",
y = "Owner's Age Group",
fill = "Number of Unique Owners") +
theme(axis.text.y = element_text(angle = 45, hjust = 1))
# Return the plot
p
})
}
shinyApp(ui = ui, server = server)
