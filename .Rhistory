aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
labs(x = "",
y = "Count",
title = "Room type count",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE) +  # Remove the legend
theme_minimal()
ggplot(Barcelona_md, aes(x = neighbourhood_group)) +
geom_bar(aes(fill = room_type), position = "dodge") +
facet_wrap(~ room_type, scales = "free_y", nrow = 2) +
theme_minimal() +
labs(title = "Acommodation type by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Count") +
theme_minimal() +
theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
license_count <- Barcelona_md %>%
group_by(LicenseGrouping) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(license_count,
aes(x = reorder(LicenseGrouping, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Count",
title = "License status",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
tenant_count <- tenants %>%
group_by(TenantSizeGrouping) %>%
summarise(listing_count = n())
# Host numbers: great vs. small tenants
plotA <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = listing_count,
fill = "red")) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Host count",
title = "Large vs. small tenants - Host count",
subtitle = "Barcelona") +
geom_text(aes(label = listing_count),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
# Listing numbers: great vs. small tenants
tenant_count <- Barcelona_md %>%
group_by(TenantSizeGrouping) %>%
summarise(quantity = n())
plotB <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Listing Count",
title = "Large vs. small tenants - Listing count",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
grid.arrange(plotA, plotB, ncol = 1)
listings_per_host <- Barcelona_md %>%
group_by(host_id) %>%
summarize(count = n(), .groups = 'drop') %>%
filter(!is.na(host_id))
# Group all counts of 10 or more into '10+'
listings_per_host$count_grouped <- ifelse(listings_per_host$count > 10,
"10+",
as.character(listings_per_host$count))
# Convert the column to a factor to control the order in the plot
listings_per_host$count_grouped <- factor(listings_per_host$count_grouped,
levels = c(as.character(1:10),
"10+"))
# Create the histogram
ggplot(listings_per_host, aes(x = count_grouped)) +
geom_bar(fill = "#f1796f") +
labs(x = "Listing count",
y = "Number of hosts",
title = "Number of hosts per listing count",
subtitle = "Barcelona") +
theme(axis.text.x = element_text()) +
theme_minimal()
top_hosts <- Barcelona_md %>%
distinct(host_id, .keep_all = TRUE) %>%
arrange(desc(calculated_host_listings_count)) %>%
slice_head(n = 5)
# Create the ggplot2 horizontal barplot
ggplot(top_hosts, aes(x = reorder(host_name, calculated_host_listings_count),
y = calculated_host_listings_count)) +
geom_bar(stat = "identity",
fill = "#f1796f") +
geom_text(aes(label = calculated_host_listings_count),
hjust = 0,
color = "black",
size = 3) +
labs(title = "Top 5 hosts by number of listings",
subtitle = "Barcelona",
x = "",
y = "Listing count") +
coord_flip() + # Flip the plot to horizontal bars
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1))
# Calculate the mean price for each neighborhood
mean_price_by_neighbourhood <- aggregate(price ~ neighbourhood, merged_data, mean)
median(Barcelona_md$price)
mean(Barcelona_md$price)
median(Barcelona_md$price, na.rm = TRUE)
mean(Barcelona_md$Eixample$price)
mean(Barcelona_md$neighbourhood_group = "Eixample")
str(Barcelona_md)
median(Barcelona_md$price[Barcelona_md$neighbourhood_group == "Eixample"], na.rm = TRUE)
median(Barcelona_md$price[Barcelona_md$neighbourhood_group == "Ciutat Vella"], na.rm = TRUE)
geojson_BCN$abbrev_neighbourhood
knitr::opts_chunk$set(echo = TRUE)
geojson_BCN$abbrev_neighbourhood <- str_wrap(geojson_BCN$neighbourhood,
width = 10)
library(stringr)
# Add abbreviated neighbourhood name
geojson_BCN$abbrev_neighbourhood <- str_wrap(geojson_BCN$neighbourhood,
width = 10)
geojson_BCN$abbrev_neighbourhood
perf <- ROCR::performance(pred, "tpr", "fpr")
# Confusion matrix plot
net_ggplot <- ggplot(data = cm_binary_df, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile() +
scale_fill_gradient(low = "mistyrose", high = "darksalmon") +
geom_text(aes(label = Freq), vjust = 1) +
theme_minimal() +
labs(title = "Binary Confusion Matrix", x = "True", y = "Predicted") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Chunk 1: setup
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
install.packages("RColorBrewer")
}
library(RColorBrewer)
# forcats
if (!require(forcats, quietly = TRUE)) {
install.packages("forcats")
}
library(forcats)
# shiny
if (!require(shiny, quietly = TRUE)) {
install.packages("shiny")
}
library(shiny)
# treemap
if (!require(treemap, quietly = TRUE)) {
install.packages("treemap")
}
library(treemap)
# Chunk 2: loading
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
setwd("~/GitHub/MachineLearningMethods")
# Chunk 1: setup
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
install.packages("RColorBrewer")
}
library(RColorBrewer)
# forcats
if (!require(forcats, quietly = TRUE)) {
install.packages("forcats")
}
library(forcats)
# shiny
if (!require(shiny, quietly = TRUE)) {
install.packages("shiny")
}
library(shiny)
# treemap
if (!require(treemap, quietly = TRUE)) {
install.packages("treemap")
}
library(treemap)
# Chunk 2: loading
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
# Chunk 3: translation
# Duplicate and rename df for English version
df_EN <- df
# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
for (i in seq_along(patterns)) {
text <- str_replace_all(text, patterns[i], replacements[i])
}
return(text)
}
# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
# Optional: Print unique values to check the translations
print(unique(df_EN$MixedBreed))
print(unique(df_EN$BreedType))
print(unique(df_EN$DogColor))
write.csv(df_EN, "df_EN.csv", row.names = FALSE)
# Chunk 4: df_unique_OwnerId
df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
head(df_EN)
# Chunk 5: new_df
# Create a new DataFrame with selected columns and convert 'NumberOfDogs' to numeric
new_df <- df_EN %>%
select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear, DogAgeGroupCd, DogSex, NumberOfDogs, unique_OwnerId) %>%
mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs)))
head(new_df, 5)
# Chunk 6: structure
# Load dataset
str(df_EN)
# Chunk 7: unique_years
# Extract and count unique years
unique_years <- unique(new_df$KeyDateYear)
number_of_unique_years <- length(unique_years)
print(number_of_unique_years)
print(unique_years)
# Chunk 8: unique_OwnerId
# Extract and count unique Owner IDs
unique_Owner <- unique(new_df$OwnerId)
number_of_unique_Owner <- length(unique_Owner)
print(number_of_unique_Owner)
# Chunk 9: shiny
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:",
choices = unique(new_df$KeyDateYear)),
selectInput("selectedGender", "Select Gender:",
choices = c("All" = "all", "Male" = "male", "Female" = "female")),
helpText("Displays unique owner IDs by age group and selected gender for the chosen year.")
),
mainPanel(
plotOutput("genderPlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$genderPlot <- renderPlot({
# Aggregate unique Owner IDs by Age Group, Year, and Gender
if (input$selectedGender == "all") {
# Sum across both genders
unique_owner_counts_gender <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop')
} else {
# Filter for a specific gender
unique_owner_counts_gender <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarise(UniqueOwnerCountGender = n_distinct(OwnerId), .groups = 'drop') %>%
filter(OwnerSex == input$selectedGender)
}
# Adjust factor levels
unique_owner_counts_gender$OwnerAgeGroup <- factor(unique_owner_counts_gender$OwnerAgeGroup,
levels = unique(new_df$OwnerAgeGroup[order(new_df$OwnerAgeGroup)]))
# Filter data for the specific year
data_for_year_gender <- filter(unique_owner_counts_gender, KeyDateYear == as.numeric(input$selectedYear))
# Create the plot
ggplot(data_for_year_gender, aes(x = OwnerAgeGroup, y = UniqueOwnerCountGender, fill = OwnerAgeGroup)) +
geom_bar(stat = "identity", position = "dodge") +
geom_text(aes(label = UniqueOwnerCountGender), vjust = -0.5, color = "black", size = 3.5) +
geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = paste("Unique Owner IDs by Age Group and", input$selectedGender, "in", input$selectedYear),
x = "Owner Age Group",
y = "Count of Unique Owner IDs") +
scale_fill_brewer(palette = "Paired") +
scale_y_continuous(limits = c(0, max(2000, max(data_for_year_gender$UniqueOwnerCountGender) + 500)), breaks = seq(0, 2000, by = 500)) +
scale_x_discrete(labels = function(x) {
x <- gsub("[0-9]+ to [0-9]+ years old", "", x)
gsub("Unknown", "", x)
})
})
}
shinyApp(ui = ui, server = server)
# Chunk 10: cs seasonal trend of Age Group
# Aggregate unique Owner IDs by Age Group and Year
unique_owner_counts <- new_df %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCount = n_distinct(OwnerId), .groups = 'drop')
# Adjust factor levels in the aggregated data before plotting
unique_owner_counts <- unique_owner_counts %>%
arrange(desc(UniqueOwnerCount)) %>%
mutate(OwnerAgeGroup = fct_inorder(OwnerAgeGroup),
KeyDateYear = as.numeric(as.character(KeyDateYear)))  # Convert KeyDateYear to numeric
# Create the line plot for all years with a line per age group
p <- ggplot(unique_owner_counts, aes(x = KeyDateYear, y = UniqueOwnerCount, group = OwnerAgeGroup, color = OwnerAgeGroup)) +
geom_line(size = 1) +  # Add line
geom_point(size = 3) +  # Add points
geom_hline(yintercept = c(100, 500, 1000, 1500, 2000), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Unique Owner IDs by Age Group Over Years",
x = "Year",
y = "Count of Unique Owner IDs") +
scale_color_brewer(palette = "Paired") +  # Use color to differentiate lines
scale_y_continuous(limits = c(0, 2500), breaks = seq(0, 2500, by = 500)) +
scale_x_continuous(breaks = seq(min(unique_owner_counts$KeyDateYear), max(unique_owner_counts$KeyDateYear), by = 1))  # Define breaks in the x-axis scale to show each year
# Print the plot
print(p)
# Chunk 11: shiny
# Convert NumberOfDogs to numeric
new_df <- new_df %>%
mutate(NumberOfDogs = as.numeric(NumberOfDogs))
# Check for any conversion problems
sum(is.na(new_df$NumberOfDogs))
# Convert KeyDateYear to numeric
new_df$KeyDateYear <- as.numeric(as.character(new_df$KeyDateYear))
# Aggregate data to get total number of dogs per year
yearly_dog_counts <- new_df %>%
group_by(KeyDateYear) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
# Calculate the percentage change for annotations
yearly_dog_counts <- yearly_dog_counts %>%
arrange(KeyDateYear) %>%
mutate(Change = c(NA, diff(TotalDogs)),
PercentChange = Change / lag(TotalDogs) * 100)
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
helpText("Click on a year in the bar plot to see the percentage change in dog registrations."),
plotOutput("dogPlot", click = "plot_click"),
verbatimTextOutput("click_info")
),
mainPanel(
plotOutput("dogChangePlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$dogPlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear,
labels = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
output$click_info <- renderPrint({
if (!is.null(input$plot_click)) {
year_clicked <- round(input$plot_click$x)
year_data <- yearly_dog_counts %>%
filter(KeyDateYear == year_clicked)
if (nrow(year_data) > 0) {
cat("Year:", year_data$KeyDateYear, "\n")
cat("Total Dogs:", year_data$TotalDogs, "\n")
cat("Percentage Change:", sprintf("%.1f%%", year_data$PercentChange), "\n")
} else {
cat("No data available for the selected year.")
}
}
})
output$dogChangePlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +
geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)),
vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom")
})
}
shinyApp(ui = ui, server = server)
