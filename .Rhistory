# Plot the neural network
plot(final_model)
setwd("~/GitHub/MachineLearningMethods")
# Load required libraries
# dplyr: For data manipulation
if (!require(dplyr, quietly = TRUE)) {
install.packages("dplyr")
library(dplyr)
}
# stringr: For string manipulation
if (!require(stringr, quietly = TRUE)) {
install.packages("stringr")
library(stringr)
}
# plotly: For interactive plots
if (!require(plotly, quietly = TRUE)) {
install.packages("plotly")
library(plotly)
}
# ggplot2: For data visualization
if (!require(ggplot2, quietly = TRUE)) {
install.packages("ggplot2")
library(ggplot2)
}
# readxl: For reading Excel files
if (!require(readxl, quietly = TRUE)) {
install.packages("readxl")
library(readxl)
}
# readr: For reading data
if (!require(readr, quietly = TRUE)) {
install.packages("readr")
}
library(readr)
# treemapify: For creating treemaps
if (!require(treemapify, quietly = TRUE)) {
install.packages("treemapify")
}
library(treemapify)
# scales: For scale functions
if (!require(scales, quietly = TRUE)) {
install.packages("scales")
}
library(scales)
# patchwork: For combining ggplots
if (!require(patchwork, quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# gridExtra: For arranging plots
if (!require(gridExtra, quietly = TRUE)) {
install.packages("gridExtra")
}
library(gridExtra)
# rcolorbrewer
if (!require(RColorBrewer, quietly = TRUE)) {
install.packages("RColorBrewer")
}
library(RColorBrewer)
# forcats
if (!require(forcats, quietly = TRUE)) {
install.packages("forcats")
}
library(forcats)
# shiny
if (!require(shiny, quietly = TRUE)) {
install.packages("shiny")
}
library(shiny)
# treemap
if (!require(treemap, quietly = TRUE)) {
install.packages("treemap")
}
library(treemap)
# Load dataset
df <- read.csv("Datasets/kul100od1001.csv")
# Check if "Datasets/df_EN.csv" exists
if (!file.exists("Datasets/df_EN.csv")) {
# Duplicate and rename df for English version
df_EN <- df
# Define translations for column names in English
colnames(df_EN) <- c("KeyDateYear", "DataStatusCd", "OwnerId", "OwnerAgeGroupCd", "OwnerAgeGroup", "OwnerAgeGroupSort", "OwnerSexCd", "OwnerSex", "OwnerSexSort", "DistrictCd", "District", "DistrictSort", "QuarCd", "Quar", "QuarSort", "PrimaryBreed", "SecondaryBreed", "MixedBreedCd", "MixedBreed", "MixedBreedSort", "BreedTypeCd", "BreedType", "BreedTypeSort", "DogBirthYear", "DogAgeGroupCd", "DogAgeGroup", "DogAgeGroupSort", "DogSexCd", "DogSex", "DogSexSort", "DogColor", "NumberOfDogs")
# Define a function to replace multiple patterns at once
replace_patterns <- function(text, patterns, replacements) {
for (i in seq_along(patterns)) {
text <- str_replace_all(text, patterns[i], replacements[i])
}
return(text)
}
# Define patterns and replacements for content translation
patterns <- c("- bis ", "-Jährige", "männlich", "weiblich", "Keine", "Unbekannt", "Rassehund", "Mischling, beide Rassen bekannt", "Mischling, sekundäre Rasse unbekannt", "Mischling, beide Rassen unbekannt", "Kleinwüchsig", "Rassentypenliste I", "Rassentypenliste II")
replacements <- c(" to ", " years old", "male", "female", "none", "Unknown", "Pedigree dog", "Mixed breed, both breeds known", "Mixed breed, secondary breed unknown", "Mixed breed, both breeds unknown", "Small stature", "Breed type list I", "Breed type list II")
# Apply the function across all columns
df_EN[] <- lapply(df_EN, function(x) replace_patterns(x, patterns, replacements))
# Color translation - can be further customized based on your dataset
color_patterns <- c("schwarz", "braun", "weiss", "grau", "silber", "rot", "gelb", "hell", "dunkel", "gestromt", "schimmel", "zweifarbig", "dreifarbig", "vierfarbig", "gemischt", "meliert", "hirschrot mit Maske", "löwenfarbig")
color_replacements <- c("black", "brown", "white", "gray", "silver", "red", "yellow", "light", "dark", "brindle", "mold", "2 colors", "3 colors", "4 colors", "mixed", "mottled", "stag red with mask", "lion-colored")
# Translate dog colors
df_EN$DogColor <- replace_patterns(df_EN$DogColor, color_patterns, color_replacements)
write.csv(df_EN, "Datasets/df_EN.csv", row.names = FALSE)
} else {
print("English version already saved")
}
# Clean import of dataset
df_EN <- read.csv("Datasets/df_EN.csv")
df_EN$unique_OwnerId <- !duplicated(df_EN$OwnerId)
head(df_EN)
df_EN_EDA <- df_EN %>%
dplyr::select(KeyDateYear, OwnerId, OwnerAgeGroup, OwnerSex, DistrictSort, QuarCd, PrimaryBreed, SecondaryBreed, MixedBreed, BreedType, DogBirthYear, DogAgeGroupCd, DogSex, NumberOfDogs, unique_OwnerId) %>%
mutate(NumberOfDogs = as.numeric(as.character(NumberOfDogs))) %>% # Convert NumberOfDogs to numeric
mutate(across(where(is.character), factor)) %>%
mutate_at(vars(DistrictSort, QuarCd), factor)
# Load dataset
str(df_EN)
# Extract and count unique years
unique_years <- unique(df_EN_EDA$KeyDateYear)
number_of_unique_years <- length(unique_years)
print(number_of_unique_years)
print(unique_years)
# Extract and count unique Owner IDs
unique_Owner <- unique(df_EN_EDA$OwnerId)
number_of_unique_Owner <- length(unique_Owner)
print(number_of_unique_Owner)
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
selectInput("selectedYear", "Select Year:",
choices = unique(df_EN_EDA$KeyDateYear)),
selectInput("selectedSex", "Select Sex:",
choices = c("All" = "all", "Male" = "male", "Female" = "female")),
helpText("Displays unique owner IDs by age group and selected sex for the chosen year.")
),
mainPanel(
plotOutput("SexPlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$SexPlot <- renderPlot({
# Aggregate unique Owner IDs by Age Group, Year, and Sex
if (input$selectedSex == "all") {
# Sum across both Sexs
unique_owner_counts_Sex <- df_EN_EDA %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCountSex = n_distinct(OwnerId), .groups = 'drop')
} else {
# Filter for a specific Sex
unique_owner_counts_Sex <- df_EN_EDA %>%
group_by(KeyDateYear, OwnerAgeGroup, OwnerSex) %>%
summarise(UniqueOwnerCountSex = n_distinct(OwnerId), .groups = 'drop') %>%
filter(OwnerSex == input$selectedSex)
}
# Adjust factor levels
unique_owner_counts_Sex$OwnerAgeGroup <- factor(unique_owner_counts_Sex$OwnerAgeGroup,
levels = unique(df_EN_EDA$OwnerAgeGroup[order(df_EN_EDA$OwnerAgeGroup)]))
# Filter data for the specific year
data_for_year_Sex <- filter(unique_owner_counts_Sex, KeyDateYear == as.numeric(input$selectedYear))
# Define gradient colors for discrete levels
gradient_colors <- colorRampPalette(c("darkslategray2", "darkslategray"))(length(levels(unique_owner_counts_Sex$OwnerAgeGroup)))
names(gradient_colors) <- levels(unique_owner_counts_Sex$OwnerAgeGroup)
# Create the plot
ggplot(data_for_year_Sex, aes(x = OwnerAgeGroup, y = UniqueOwnerCountSex, fill = OwnerAgeGroup)) +
geom_bar(stat = "identity", position = "dodge") +
geom_text(aes(label = UniqueOwnerCountSex), vjust = -0.5, color = "black", size = 3.5) +
geom_hline(yintercept = c(100, 500, 1000, 1500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = paste("Unique Owner IDs by Age Group and", input$selectedSex, "in", input$selectedYear),
x = "Owner Age Group",
y = "Count of Unique Owner IDs",
fill = "Owner Age Group") +
scale_fill_manual(values = gradient_colors) +
scale_y_continuous(limits = c(0, max(2000, max(data_for_year_Sex$UniqueOwnerCountSex) + 500)), breaks = seq(0, 2000, by = 500)) +
scale_x_discrete(labels = function(x) {
x <- gsub("[0-9]+ to [0-9]+ years old", "", x)
gsub("Unknown", "", x)
})
})
}
shinyApp(ui = ui, server = server)
# Aggregate unique Owner IDs by Age Group and Year
unique_owner_counts <- df_EN_EDA %>%
group_by(KeyDateYear, OwnerAgeGroup) %>%
summarise(UniqueOwnerCount = n_distinct(OwnerId), .groups = 'drop')
# Adjust factor levels in the aggregated data before plotting
unique_owner_counts <- unique_owner_counts %>%
arrange(desc(UniqueOwnerCount)) %>%
mutate(OwnerAgeGroup = factor(OwnerAgeGroup, levels = unique(df_EN_EDA$OwnerAgeGroup[order(df_EN_EDA$OwnerAgeGroup)])),
KeyDateYear = as.numeric(as.character(KeyDateYear)))  # Convert KeyDateYear to numeric
# Define gradient colors for discrete levels
gradient_colors <- colorRampPalette(c("darkslategray2", "darkslategray"))(length(levels(unique_owner_counts$OwnerAgeGroup)))
names(gradient_colors) <- levels(unique_owner_counts$OwnerAgeGroup)
# Create the line plot for all years with a line per age group
p <- ggplot(unique_owner_counts, aes(x = KeyDateYear, y = UniqueOwnerCount, group = OwnerAgeGroup, color = OwnerAgeGroup)) +
geom_line(size = 1) +  # Add line
geom_point(size = 3) +  # Add points
geom_hline(yintercept = c(100, 500, 1000, 1500, 2000), linetype = "dashed", color = "red") +
theme_minimal() +
labs(x = "Year",
y = "Count of Unique Owner IDs",
color = "Owner Age Group") +  # Label for the legend
scale_color_manual(values = gradient_colors) +  # Use gradient colors
scale_y_continuous(limits = c(0, 2500), breaks = seq(0, 2500, by = 500)) +
scale_x_continuous(breaks = seq(min(unique_owner_counts$KeyDateYear), max(unique_owner_counts$KeyDateYear), by = 1))  # Define breaks in the x-axis scale to show each year
# Print the plot
ggplotly(p)
df_EN_EDA2 <- df_EN_EDA
# Convert NumberOfDogs to numeric
df_EN_EDA2 <- df_EN_EDA2 %>%
mutate(NumberOfDogs = as.numeric(NumberOfDogs))
# Check for any conversion problems
sum(is.na(df_EN_EDA2$NumberOfDogs))
# Convert KeyDateYear to numeric
df_EN_EDA2$KeyDateYear <- as.numeric(as.character(df_EN_EDA2$KeyDateYear))
# Aggregate data to get total number of dogs per year
yearly_dog_counts <- df_EN_EDA2 %>%
group_by(KeyDateYear) %>%
summarize(TotalDogs = sum(NumberOfDogs), .groups = 'drop')
# Calculate the percentage change for annotations
yearly_dog_counts <- yearly_dog_counts %>%
arrange(KeyDateYear) %>%
mutate(Change = c(NA, diff(TotalDogs)),
PercentChange = Change / lag(TotalDogs) * 100)
# Define UI
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
helpText("Click on a year in the bar plot to see the percentage change in dog registrations."),
plotOutput("dogPlot", click = "plot_click"),
verbatimTextOutput("click_info")
),
mainPanel(
plotOutput("dogChangePlot")
)
)
)
# Define server logic
server <- function(input, output) {
output$dogPlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear,
labels = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
output$click_info <- renderPrint({
if (!is.null(input$plot_click)) {
year_clicked <- round(input$plot_click$x)
year_data <- yearly_dog_counts %>%
filter(KeyDateYear == year_clicked)
if (nrow(year_data) > 0) {
cat("Year:", year_data$KeyDateYear, "\n")
cat("Total Dogs:", year_data$TotalDogs, "\n")
cat("Percentage Change:", sprintf("%.1f%%", year_data$PercentChange), "\n")
} else {
cat("No data available for the selected year.")
}
}
})
output$dogChangePlot <- renderPlot({
ggplot(yearly_dog_counts, aes(x = KeyDateYear, y = TotalDogs)) +
geom_col(fill = "darkseagreen") +
geom_hline(yintercept = c(2500, 5000, 7500), linetype = "dashed", color = "red") +
geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +
geom_text(data = yearly_dog_counts, aes(label = sprintf("%.1f%%", PercentChange)),
vjust = -1.5, hjust = 0.5, color = "darkgreen", size = 3.5) +
theme_minimal() +
labs(title = "Total Number of Dogs per Year",
x = "Year",
y = "Total Number of Dogs") +
scale_x_continuous(breaks = yearly_dog_counts$KeyDateYear) +
scale_y_continuous(labels = scales::comma,
breaks = seq(0, 10000, by = 1000),
limits = c(0, 10000)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "bottom")
})
}
shinyApp(ui = ui, server = server)
render("ML1_Final_Dogs.Rmd", output_format = "html_document")
setwd("~/GitHub/MachineLearningMethods")
render("ML1_Final_Dogs.Rmd", output_format = "html_document")
library(rmarkdown)
render("ML1_Final_Dogs.Rmd", output_format = "html_document")
